{"mappings":"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","sources":["<anon>","src/web/scripts/index.js","src/package/web.js","src/package/components/index.js","src/package/components/BlurridImage.js","src/package/dct/index.js","src/package/dct/array-conversions.js","src/package/utils/decorate-cli.js","src/package/dct/BlurridDecoder.js","src/package/dct/BlurridMetadata.js","src/package/dct/builders.js","src/package/dct/SubsampleSelector.js","src/package/utils/index.js","src/package/utils/BitBuffer.js","src/package/utils/WorkerManager.js","src/package/dct/colorspace-conversions.js","src/package/dct/decode.js","src/package/dct/serialize.js","src/package/dct/BlurridEncoder.js","src/package/dct/consumers.js","src/package/dct/encode.js","src/package/shader/index.js","src/package/shader/canvas.js","src/package/shader/shader.vert","src/package/shader/shader.frag","src/package/shader/decode.js","src/package/shader/worker-instance.js","src/package/components/BlurridImageWorker.js","src/web/scripts/icons.js"],"sourcesContent":["import {createIcons as $cw5NC$createIcons, Info as $cw5NC$Info} from \"lucide\";\n\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Demo site entrypoint.\n * @author James Reid\n */ // @ts-check\n// @@imports-dependencies\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Web image component and utility entrypoint.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@no-body\n// @@exports\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Export custom blurrid web components.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@no-body\n// @@exports\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file BlurridImage web component, not including worker fallback.\n * @author James Reid\n */ // @ts-check\n// @@imports-package\n// Copyright (c) 2023 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Export dct compression methods.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@no-body\n// @@exports\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Array dimension conversions for jpg dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@imports-utils\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Functions for decorating cli strings.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n * Custom error which renders an error in a uniform way, taking an options\n * object with reserved name and message fields, and then any other fields\n * relevant to the error, and rendering them with indentation.\n */ class $365a44e770a0b11c$export$39785c5d1570d2b1 extends Error {\n    /**\n   * Build new error based on supplied options object which may set the custom\n   * name of the error, the top level message of the error, and then any\n   * number of other custom fields.\n   *\n   * @param {Object.<string,string|number|boolean>} options - Options object\n   *      containing any string keys, and string, number or boolean values.\n   */ constructor(options){\n        super();\n        let message = \"\";\n        // Parse all properties in options argument; if key is name, use value\n        // to set the custom name of the error, if key is message, append value\n        // top of error message, otherwise render a grey, tabbed key-value\n        // pair to the end of the message string.\n        for(const key in options)switch(key){\n            case \"name\":\n                this.name = /** @type {string} */ options[key];\n                break;\n            case \"message\":\n                message = `${options[key]}\\n${message}`;\n                break;\n            default:\n                {\n                    const detail = `${key}: ${options[key]}`;\n                    message = `${message}${$365a44e770a0b11c$export$83736ebe6a735486(detail, \"gray\", 1)}\\n`;\n                }\n        }\n        // Set error message which will be displayed.\n        this.message = message || \"\";\n    }\n}\n/**\n * Decorate a string with control characters for changing cli string colors and\n * text decoration. Adds supplied list of modifiers for the string, then uses\n * reset character to set text back to default.\n *\n * @summary Return original string decorated with control characters.\n * @param {string} string - String to be decorated.\n * @param {object} options - Options object.\n * @param {string[]=} options.modifiers - String array of modifiers/control\n *      characters to apply input string.\n * @param {number=} options.tabs - Number of tab indents to include on string.\n * @param {number=} options.tabSize - Number of spaces for each tab.\n * @returns {string} Original string decorated with control characters.\n */ const $365a44e770a0b11c$export$c80826d3392ea781 = (string, { modifiers: modifiers = [], tabs: tabs = 0, tabSize: tabSize = 4 } = {})=>{\n    // Make compound modifier string form array of supplied control characters.\n    let compoundModifier = \"\";\n    for (const modifier of modifiers)compoundModifier = `${compoundModifier}${modifier}`;\n    // Wrap input string with control characters and reset character.\n    const reset = $365a44e770a0b11c$export$e1ac8087f5f1bfe7.decorations.reset;\n    const indent = \" \".repeat(tabs * tabSize);\n    return `${compoundModifier}${indent}${string}${reset}`;\n};\n/**\n * Wrapper around decorate function to decorate a string with a foreground\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a foreground colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired foreground colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */ const $365a44e770a0b11c$export$83736ebe6a735486 = (string, color, tabs = 0)=>{\n    const colorModifier = $365a44e770a0b11c$export$e1ac8087f5f1bfe7.fgColors[color];\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier ? $365a44e770a0b11c$export$c80826d3392ea781(string, {\n        modifiers: [\n            colorModifier\n        ],\n        tabs: tabs\n    }) : $365a44e770a0b11c$export$c80826d3392ea781(string, {\n        tabs: tabs\n    });\n};\n/**\n * Wrapper around decorate function to decorate a string with a background\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a background colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired background colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */ const $365a44e770a0b11c$export$452607015d3d1c9f = (string, color, tabs = 0)=>{\n    const colorModifier = $365a44e770a0b11c$export$e1ac8087f5f1bfe7.bgColors[color];\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier ? $365a44e770a0b11c$export$c80826d3392ea781(string, {\n        modifiers: [\n            colorModifier\n        ],\n        tabs: tabs\n    }) : $365a44e770a0b11c$export$c80826d3392ea781(string, {\n        tabs: tabs\n    });\n};\n/**\n * Wrapper around String.prototype.padEnd method, which pads end of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad end of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padEnd method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */ const $365a44e770a0b11c$export$30fcb72c6bf87eba = (string, maxLength, fillString)=>{\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0;\n    return string.padEnd(maxLength + decoratorLength, fillString);\n};\n/**\n * Wrapper around String.prototype.padStart method, which pads start of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad start of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padStart method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */ const $365a44e770a0b11c$export$adfb6bac270c262a = (string, maxLength, fillString)=>{\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0;\n    return string.padStart(maxLength + decoratorLength, fillString);\n};\n// Object of cli control strings for decorations etc.\nconst $365a44e770a0b11c$export$e1ac8087f5f1bfe7 = {\n    // Foreground modifiers.\n    /** @type {Object.<string,string>} */ fgColors: {\n        black: \"\\x1b[30m\",\n        red: \"\\x1b[31m\",\n        green: \"\\x1b[32m\",\n        yellow: \"\\x1b[33m\",\n        blue: \"\\x1b[34m\",\n        magenta: \"\\x1b[35m\",\n        cyan: \"\\x1b[36m\",\n        white: \"\\x1b[37m\",\n        gray: \"\\x1b[90m\"\n    },\n    // Background modifiers.\n    /** @type {Object.<string,string>} */ bgColors: {\n        black: \"\\x1b[40m\",\n        red: \"\\x1b[41m\",\n        green: \"\\x1b[42m\",\n        yellow: \"\\x1b[43m\",\n        blue: \"\\x1b[44m\",\n        magenta: \"\\x1b[45m\",\n        cyan: \"\\x1b[46m\",\n        white: \"\\x1b[47m\",\n        gray: \"\\x1b[100m\"\n    },\n    // Decoration modifiers.\n    /** @type {Object.<string,string>} */ decorations: {\n        reset: \"\\x1b[0m\",\n        bright: \"\\x1b[1m\",\n        dim: \"\\x1b[2m\",\n        underline: \"\\x1b[4m\",\n        blink: \"\\x1b[5m\",\n        reverse: \"\\x1b[7m\",\n        hidden: \"\\x1b[8m\"\n    }\n};\n/**\n * Convert kebab-case string to camelCase string, removing all hyphens in input\n * string, and capitalising the first character following each hyphen. Options\n * available for generating UpperCamelCase strings, and spaced strings too.\n *\n * @summary Convert kebab-case string to camelCase string.\n * @param {string} kebabCaseString - Input kebab-case string.\n * @param {boolean} isUpper - Should return string be in UpperCamelCase?\n * @param {boolean} isSpaced - Should return string replace hyphens with\n *      whitespace characters?\n * @returns {string} camelCase string version of input.\n */ const $365a44e770a0b11c$export$86f54f62aa7a7514 = (kebabCaseString, isUpper = false, isSpaced = false)=>{\n    // Reduce split input string with starting value object containing an empty\n    // string and flag set to isUpper for if next character should be capital.\n    return kebabCaseString.split(\"\").reduce((acc, cur)=>{\n        // Ignore hyphens, or replace with spaces as required.\n        if (cur === \"-\") return isSpaced ? {\n            string: `${acc.string} `,\n            isCapital: true\n        } : {\n            ...acc,\n            isCapital: true\n        };\n        // Concatenate string with next character set to uppercase if required.\n        const nextChar = acc.isCapital ? cur.toUpperCase() : cur.toLowerCase();\n        return {\n            string: `${acc.string}${nextChar}`,\n            isCapital: false\n        };\n    }, {\n        string: \"\",\n        isCapital: isUpper\n    }).string;\n};\n/**\n * Convert camelCaseString to kebab-case-string, adding hyphens between words.\n * If input string includes spaces (for example the verbatim title of a\n * markdown documentation file), replace with hyphens - this is good for\n * converting a title string to a valid kebab-case-filename. Option also\n * available for generating Upper-Kebab-Case strings.\n *\n * @summary Convert camelCaseString to kebab-case-string.\n * @param {string} camelCaseString - Input camelCaseString.\n * @param {boolean} isUpper - Should return string be in Upper-Kebab-Case?\n * @returns {string} kebab-case-string version of input.\n */ const $365a44e770a0b11c$export$73bda83cddbc7187 = (camelCaseString, isUpper = false)=>{\n    // Reduce split input string with starting value object containing an empty\n    // string and a new word flag set to true.\n    return camelCaseString.split(\"\").reduce((acc, cur)=>{\n        // Ignore spaces in the input string, but set new word flag to true.\n        if (cur === \" \") return {\n            ...acc,\n            isNewWord: true\n        };\n        else if (acc.isNewWord || cur.match(/[A-Z]/)) {\n            const nextChar = isUpper ? cur.toUpperCase() : cur.toLowerCase();\n            return acc.string ? {\n                string: `${acc.string}-${nextChar}`,\n                isNewWord: false\n            } : {\n                string: `${nextChar}`,\n                isNewWord: false\n            };\n        }\n        // Otherwise, append current letter in lowercase.\n        const nextChar = cur.toLowerCase();\n        return {\n            string: `${acc.string}${nextChar}`,\n            isNewWord: false\n        };\n    }, {\n        string: \"\",\n        isNewWord: true\n    }).string;\n};\n\n\n// @@body\n/**\n *\n * @param {number[]} sampleData\n * @param {number} width\n * @param {number} channels\n * @returns {number[][][]}\n */ const $931f6948e16b2f88$export$b0d6d19929940a93 = (sampleData, width, channels = 3)=>{\n    if (sampleData.length % channels) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n        name: \"ChannelError\",\n        message: \"Data length is not a multiple of requested channel count\",\n        \"data-length\": sampleData.length,\n        \"channels-requested\": channels\n    });\n    /** @type {number[][]} */ const channelData = Array.from(Array.from({\n        length: channels\n    }), ()=>[]);\n    for (const [i, pixel] of sampleData.entries())channelData[i % channels].push(pixel);\n    return channelData.map((channel)=>$931f6948e16b2f88$var$expandChannel(channel, width));\n};\n/**\n *\n * @param {number[]} channel1D\n * @param {number} width\n * @returns {number[][]}\n */ const $931f6948e16b2f88$var$expandChannel = (channel1D, width)=>{\n    if (channel1D.length % width) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n        name: \"ChannelError\",\n        message: \"Channel length is not a multiple of row width\",\n        \"channel-length\": channel1D.length,\n        \"row-width\": width\n    });\n    /** @type {number[][]} */ const channel2D = Array.from(Array.from({\n        length: channel1D.length / width\n    }), ()=>[]);\n    for (const [i, pixel] of channel1D.entries())channel2D[Math.floor(i / width)].push(pixel);\n    return channel2D;\n};\n/**\n *\n * @param {number[][][]} expandedSample\n * @returns {number[]}\n */ const $931f6948e16b2f88$export$c28500e84d42e56e = (expandedSample)=>{\n    const channelData = expandedSample.map((channel)=>$931f6948e16b2f88$var$collapseChannel(channel));\n    const length1 = channelData[0].length;\n    const sampleData = Array.from({\n        length: channelData.length * length1\n    }).fill(0);\n    for (const [i, channel] of channelData.entries()){\n        if (channel.length !== length1) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"ChannelError\",\n            message: \"Sample channels not of same length\",\n            \"default-length\": length1,\n            \"channel-length\": channel.length\n        });\n        for (const [j, pixel] of channel.entries())sampleData[channelData.length * j + i] = pixel;\n    }\n    return sampleData;\n};\n/**\n *\n * @param {number[][]} channel2D\n * @returns {number[]}\n */ const $931f6948e16b2f88$var$collapseChannel = (channel2D)=>{\n    const width = channel2D[0].length;\n    const channel1D = [];\n    for (const channelRow of channel2D){\n        if (channelRow.length !== width) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"ChannelError\",\n            message: \"Channel row width does not match sample width\",\n            \"sample-width\": length,\n            \"row-width\": channelRow.length\n        });\n        channel1D.push(...channelRow);\n    }\n    return channel1D;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Wrapper class around blurrid dct decoding functions.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Class for building and accessing dct metadata.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\nclass $04f5c56647ae8c40$export$a343f46e34a234f1 {\n    #image;\n    #sample;\n    /**\n   *\n   * @param {object} obj\n   * @param {object} obj.image\n   * @param {number} obj.image.width\n   * @param {number} obj.image.height\n   * @param {object} obj.sample\n   * @param {number} obj.sample.width\n   * @param {number} obj.sample.height\n   */ constructor({ image: image, sample: sample }){\n        this.#image = image;\n        this.#sample = {\n            ...sample,\n            max: Math.max(sample.width, sample.height)\n        };\n    }\n    /**\n   *\n   * @param {number} width\n   */ resize(width) {\n        this.#image.height = Math.round(this.#image.height * width / this.#image.width);\n        this.#image.width = width;\n    }\n    get image() {\n        return this.#image;\n    }\n    get sample() {\n        return this.#sample;\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Generators for building arrays of dct coefficients.\n * @author James Reid\n */ // @ts-check\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */ // Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Class for processing subsample strings.\n * @author James Reid\n */ // @ts-check\n// @@imports-utils\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Export utility methods.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@no-body\n// @@exports\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Buffer class allowing control at bit level rather than byte level.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n\n// @@body\n/**\n * Buffer class allowing control over an appropriately sized array buffer at the\n * bit level rather than at the byte level.\n */ class $025fa45280fd44fb$export$4f347c1cf22bbd8 {\n    #buffer;\n    #readPointer;\n    #lastReadSize;\n    #writePointer;\n    #lastWriteSize;\n    /**\n   * Configure internal buffer property and required pointers.\n   *\n   * @param {object} obj - Configuration object argument.\n   * @param {number} [obj.length] - Maximum character length of buffer when\n   *      converted to url-safe base64 string.\n   * @param {number} [obj.size] - Size of BitBuffer in *bytes*. Defaults to\n   *      maximum allowable size as specified by the character length value.\n   * @param {ArrayBuffer} [obj.buffer] - Internal array buffer.\n   */ constructor({ length: length = 16, size: size = Math.floor(length * 6 / 8), buffer: buffer = new ArrayBuffer(size) } = {}){\n        // Assign internal array buffer for implementation of BitBuffer.\n        this.#buffer = buffer;\n        // Assign internal read pointers.\n        this.#readPointer = 0;\n        this.#lastReadSize = 0;\n        // Assign internal write pointers.\n        this.#writePointer = 0;\n        this.#lastWriteSize = 0;\n    }\n    /**\n   * Write an integer directly to internal buffer, updating write pointers to\n   * the end of the written data.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.size] - Size of buffer segment to write in bits.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ write(int, { size: size = $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(int), offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable().append(int, {\n            size: size,\n            offset: offset,\n            signed: signed\n        });\n        if (!writeable.isWriteable) return NaN;\n        return this.#write(int, {\n            size: size,\n            offset: offset,\n            signed: signed\n        });\n    }\n    /**\n   * Write an integer to internal buffer with an absolute size declaration to\n   * indicate how many bits are written (i.e. 5 additional bits written\n   * indicating length of written data between 0 and 32 bits). Update write\n   * pointers to the end of the written data.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ writeAbsolute(int, { offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // Size declaration data with the size of buffer segment it will occupy.\n        const resize = {\n            value: $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(int),\n            size: 5\n        };\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable().append(resize.value, {\n            ...resize,\n            offset: offset\n        }).append(int, {\n            signed: signed\n        });\n        if (!writeable.isWriteable) return NaN;\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, {\n            ...resize,\n            offset: offset\n        });\n        const uint32 = this.#write(int, {\n            signed: signed\n        });\n        return uint32;\n    }\n    /**\n   * Write an integer to internal buffer with a relative size declaration to\n   * indicate how many bits are written (i.e. 1 \"sign\" bit to indicate if more\n   * or less bits than the previous write call are being written, and n \"0\"\n   * bits where n is the relative size between the previous and next write\n   * call sizes). Update write pointers to the end of the written data.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ writeRelative(int, { offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // Write relative method relies on the first bit of the written integer\n        // being \"1\", and therefore cannot write integer \"0\".\n        if (int === 0) int = 1;\n        // Size declaration data with the size of buffer segment it will occupy.\n        const relativeSize = $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(int) - this.#lastWriteSize;\n        const resize = {\n            // If increasing size, write a 1 bit shifted by the amount of bits\n            // the data is bigger by, otherwise write a 0. Preserve required\n            // bit length of size declaration using size property.\n            value: relativeSize > 0 ? 1 << relativeSize >>> 0 : 0,\n            size: Math.abs(relativeSize) + 1\n        };\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable().append(resize.value, {\n            ...resize,\n            offset: offset\n        }).append(int, {\n            signed: signed\n        });\n        if (!writeable.isWriteable) return NaN;\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, {\n            ...resize,\n            offset: offset\n        });\n        const uint32 = this.#write(int, {\n            signed: signed\n        });\n        return uint32;\n    }\n    /**\n   * Write a string of arbitrary length to the internal buffer.\n   *\n   * @param {string} string - String to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @returns {string} String written to buffer.\n   */ writeString(string, { offset: offset = this.#writePointer } = {}) {\n        // Size declaration data for bit length of length of string declaration.\n        const resize = {\n            value: $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(string.length),\n            size: 5\n        };\n        // If all characters are not writeable due to insufficient bits\n        // remaining etc., then return empty string.\n        let writeable = this.#writeable().append(resize.value, {\n            ...resize\n        }).append(string.length);\n        for(let i = 0; i < string.length; i++)writeable = writeable.append(0, {\n            size: 8\n        });\n        if (!writeable.isWriteable) return \"\";\n        // Write string length declaration and string to buffer.\n        this.#write(resize.value, {\n            ...resize,\n            offset: offset\n        });\n        this.#write(string.length);\n        for (const char of string)this.#write(char.charCodeAt(0), {\n            size: 8\n        });\n        return string;\n    }\n    /**\n   * Read an integer directly from internal buffer, updating read pointers to\n   * the end of the read data.\n   *\n   * @param {number} size - Size of buffer segment to read.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ read(size, { offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        // If all values are not readable due to insufficient bits remaining\n        // etc., then return no number.\n        const readable = this.#readable().append(size, {\n            offset: offset,\n            signed: signed\n        });\n        if (!readable.isReadable) return NaN;\n        return this.#read(size, {\n            offset: offset,\n            signed: signed\n        });\n    }\n    /**\n   * Read an integer from internal buffer, determining bit size of segment\n   * by reading an absolute size declaration from the buffer indicating how\n   * many bits should be read (i.e. 5 additional bits read before reading\n   * integer to determine bit size of read segment between 0 and 32 bits).\n   * Update read pointers to the end of the read data.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ readAbsolute({ offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer;\n        const lastReadSize = this.#lastReadSize;\n        // Check if sufficient read bits remain to read both the size\n        // declaration and integer.\n        const readable = this.#readable().append(5, {\n            offset: offset\n        });\n        let size = 0;\n        if (readable.isReadable) {\n            size = this.#read(5, {\n                offset: offset\n            });\n            readable.append(size, {\n                signed: signed\n            });\n        }\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer;\n            this.#lastReadSize = lastReadSize;\n            return NaN;\n        }\n        return this.#read(size, {\n            signed: signed\n        });\n    }\n    /**\n   * Read an integer from internal buffer, determining bit size of segment by\n   * reading a relative size declaration from the buffer indicating how many\n   * bit should be read (i.e. 1 \"sign\" bit to indicate if more or less bits\n   * than the previous read call are being read, and n \"0\" bits where n is the\n   * relative size between the previous and next read call sizes). Update read\n   * pointers to the end of the read data.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ readRelative({ offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer;\n        const lastReadSize = this.#lastReadSize;\n        // Get sign of relative size (i.e. are more or less bits to be read than\n        // last read call).\n        let sign = 1;\n        const readable = this.#readable().append(1, {\n            offset: offset\n        });\n        if (readable.isReadable) sign = this.#read(1, {\n            offset: offset\n        }) ? 1 : -1;\n        // Get unsigned read size relative to size of last read call (reads\n        // until first bit of integer to be read, then breaks).\n        let relativeSize = 0;\n        while(readable.append(1).isReadable){\n            if (this.#read(1)) break;\n            relativeSize++;\n        }\n        // Get size of integer to be read from buffer.\n        const size = lastReadSize + sign * relativeSize;\n        readable.append(size, {\n            signed: signed\n        });\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer;\n            this.#lastReadSize = lastReadSize;\n            return NaN;\n        }\n        // Decrement read pointer to account for first bit of integer having\n        // been read above.\n        this.#readPointer--;\n        return this.#read(size, {\n            signed: signed\n        });\n    }\n    /**\n   * Read a string of arbitrary length from the internal buffer.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @returns {string} String read from buffer.\n   */ readString({ offset: offset = this.#readPointer } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer;\n        const lastReadSize = this.#lastReadSize;\n        // Get bit size of string length declaration.\n        const readable = this.#readable().append(5, {\n            offset: offset\n        });\n        let lengthSize = 0;\n        if (readable.isReadable) lengthSize = this.#read(5, {\n            offset: offset\n        });\n        readable.append(lengthSize);\n        // Get string length.\n        let length = 0;\n        if (readable.isReadable) length = this.#read(lengthSize);\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !length) {\n            this.#readPointer = readPointer;\n            this.#lastReadSize = lastReadSize;\n            return \"\";\n        }\n        let string = \"\";\n        for(let i = 0; i < length; i++){\n            // Ensure next byte (8 bit character) is readable.\n            readable.append(8);\n            // Reset pointers and return no number if insufficient remaining\n            // read bits.\n            if (!readable.isReadable) {\n                this.#readPointer = readPointer;\n                this.#lastReadSize = lastReadSize;\n                return \"\";\n            }\n            // Read character from buffer and append to string.\n            string += String.fromCharCode(this.#read(8));\n        }\n        return string;\n    }\n    /**\n   * Copy data from source buffer (current buffer instance) to a target buffer\n   * passed in the arguments. If no target buffer passed, new BitBuffer\n   * instantiated with a length based on number of copied bits. Will update\n   * read/write pointers in both source and target buffers.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {BitBuffer} [obj.target] - Target buffer to copy to.\n   * @param {number} [obj.targetStart] - Start bit in target buffer.\n   * @param {number} [obj.sourceStart] - Start bit in source buffer.\n   * @param {number} [obj.sourceEnd] - End bit in source buffer.\n   * @returns {BitBuffer} Target buffer with data copied from source buffer.\n   */ copy({ target: target, targetStart: targetStart = target?.writePointer || 0, sourceStart: sourceStart = 0, sourceEnd: sourceEnd = this.bitLength } = {}) {\n        // Throw error if source start or end bounds are out of buffer range.\n        if (sourceStart < 0 || sourceEnd > this.bitLength) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"BitBufferError\",\n            message: \"Requested bits out of source buffer range\",\n            \"source-start\": sourceStart,\n            \"source-end\": sourceEnd,\n            \"source-bit-length\": this.bitLength\n        });\n        // Get number of source bits, and minimum size of target buffer in bytes\n        // to store the data from the source buffer.\n        const sourceBits = sourceEnd - sourceStart;\n        const targetSize = Math.ceil((sourceBits + targetStart) / 8);\n        // Get available write bits in target buffer, instantiating a BitBuffer\n        // of the correct size if none is passed in arguments.\n        target ??= new $025fa45280fd44fb$export$4f347c1cf22bbd8({\n            size: targetSize\n        });\n        const targetBits = target.bitLength - targetStart;\n        // Throw error if not sufficient bits remaining in target buffer.\n        if (sourceBits > targetBits) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"BitBufferError\",\n            message: \"Source bits exceed bits available in target buffer\",\n            \"source-bits\": sourceBits,\n            \"target-bits\": targetBits\n        });\n        // Copy data bits from source buffer to target buffer.\n        for(let i = 0; i < sourceBits; i++)target.write(this.#read(1, {\n            offset: sourceStart + i\n        }), {\n            size: 1,\n            offset: targetStart + i\n        });\n        return target;\n    }\n    /**\n   * Convert buffer to serialized string of base-64 url-safe characters.\n   *\n   * @returns {string} Serialized buffer string.\n   */ toString() {\n        // Initialize serialized string and pointers to track string fragments.\n        let string = \"\";\n        let pointer = 0;\n        let uint24 = 0;\n        // Loop over buffer, adding 4 character fragments to serialized string\n        // for every 24 bits consumed from buffer (24-bit blocks consumed in\n        // 3-byte blocks at time).\n        const view = new Uint8Array(this.#buffer);\n        for(let i = 0; i < Math.ceil(this.byteLength / 3) * 3; i++){\n            const byte = view[i] || 0;\n            uint24 = (uint24 | byte << 16 - pointer * 8) >>> 0;\n            pointer = ++pointer % 3;\n            if (!pointer) {\n                string += $025fa45280fd44fb$export$4f347c1cf22bbd8.#uint24ToB64(uint24);\n                uint24 = 0;\n            }\n        }\n        return string;\n    }\n    /**\n   * Create object containing\n   */ #writeable() {\n        //\n        const tracer = {\n            writeable: true,\n            offset: this.#writePointer\n        };\n        /**\n     *\n     * @param {number} int\n     * @param {object} obj\n     * @param {number} [obj.size]\n     * @param {number} [obj.offset]\n     * @param {boolean} [obj.signed]\n     */ const append = (int, { size: size = $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(int), offset: offset = tracer.offset, signed: signed = false } = {})=>{\n            if (tracer.writeable) {\n                const uint32 = Math.abs(int);\n                const bitsRemaining = this.bitLength - offset;\n                tracer.writeable = !signed && int < 0 ? false : $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(uint32) > size ? false : !Number.isInteger(uint32) ? false : size < 0 || size > 32 ? false : size + (signed ? 1 : 0) > bitsRemaining ? false : true;\n            }\n            tracer.offset += size;\n            return {\n                append: append,\n                get isWriteable () {\n                    return tracer.writeable;\n                }\n            };\n        };\n        return {\n            append: append,\n            get isWriteable () {\n                return tracer.writeable;\n            }\n        };\n    }\n    /**\n   * Write sanitized integer directly to internal buffer, updating write\n   * pointers to the end of the written data. This private method is called by\n   * other class write methods *after* values have been checked to ensure that\n   * they are not out of range, or will not fit in the remaining empty buffer\n   * bits.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.size] - Size of buffer segment to write in bits.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ #write(int, { size: size = $025fa45280fd44fb$export$4f347c1cf22bbd8.#bitLength(int), offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // Get absolute value of integer to write.\n        const uint32 = Math.abs(int);\n        const { view: view, byteLength: byteLength, subBit: subBit } = this.#getView(size, offset);\n        for(let i = 0; i < byteLength; i++){\n            const byte = view.getUint8(i);\n            let uint8 = 0;\n            for(let j = 0; j < 8; j++){\n                const index = i * 8 + j;\n                const bit = index < subBit || index > subBit + size ? byte << 24 + j >>> 31 : uint32 << 32 - size + (index - subBit) >>> 31;\n                uint8 = uint8 | bit << 7 - j;\n            }\n            view.setUint8(i, uint8);\n        }\n        // Update write pointer and add sign bit *after* written integer.\n        // NOTE: The sign bit is written at the end of integers in the BitBuffer\n        // as this saves a bit when using the writeRelative and readRelative\n        // methods. This is because the relative size declaration can be assumed\n        // to end at the first non-zero bit (i.e. the start of the number),\n        // rather than requiring an extra \"1\" end bit if the \"1\"/\"0\" sign bit\n        // was written at the start of the number.\n        this.#writePointer = offset + size;\n        if (signed) this.#write(int >= 0 ? 1 : 0, {\n            size: 1\n        });\n        // Update last write size *after* sign bit such that the sign bit is\n        // *not* considered as the last integer size written.\n        this.#lastWriteSize = size;\n        return int;\n    }\n    /**\n   *\n   */ #readable() {\n        const tracer = {\n            readable: true,\n            offset: this.#readPointer\n        };\n        const append = (/** @type {number} */ size, { offset: offset = tracer.offset, signed: signed = false } = {})=>{\n            if (tracer.readable) {\n                const bitsRemaining = this.bitLength - offset;\n                tracer.readable = size < 0 || size > 32 ? false : size + (signed ? 1 : 0) > bitsRemaining ? false : true;\n            }\n            tracer.offset += size;\n            return {\n                append: append,\n                get isReadable () {\n                    return tracer.readable;\n                }\n            };\n        };\n        return {\n            append: append,\n            get isReadable () {\n                return tracer.readable;\n            }\n        };\n    }\n    /**\n   * Read sanitized integer directly from internal buffer, updating write\n   * pointers to the end of the read data. This private method is called by\n   * other class read methods *after* values have been checked to ensure that\n   * they are not out of range.\n   *\n   * @param {number} size - Size of buffer segment to read.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ #read(size, { offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        const { view: view, byteLength: byteLength, subBit: subBit } = this.#getView(size, offset);\n        let uint32 = 0;\n        for(let i = 0; i < byteLength; i++){\n            const offset = 24 + subBit - i * 8;\n            uint32 = offset >= 0 ? (uint32 | view.getUint8(i) << offset) >>> 0 : (uint32 | view.getUint8(i) >>> -offset) >>> 0;\n        }\n        this.#readPointer = offset + size;\n        const sign = signed && this.#read(1) === 0 ? -1 : 1;\n        this.#lastReadSize = size;\n        return sign * (uint32 >>> 32 - size);\n    }\n    /**\n   *\n   * @param {*} size\n   * @param {*} offset\n   * @returns {{view:DataView,byteLength:number,subBit:number}} Object\n   *      containing requested dataview of BitBuffer at the given offset.\n   */ #getView(size, offset) {\n        const startByte = Math.floor(offset / 8);\n        const subBit = offset - 8 * startByte;\n        const byteLength = Math.ceil((subBit + size) / 8);\n        this.byteLength;\n        const view = new DataView(this.#buffer, startByte, byteLength);\n        return {\n            view: view,\n            byteLength: byteLength,\n            subBit: subBit\n        };\n    }\n    /**\n   * Get length of buffer in bits.\n   *\n   * @returns {number} Bit length of buffer.\n   */ get bitLength() {\n        return this.byteLength << 3;\n    }\n    /**\n   * Get length of buffer in bytes.\n   *\n   * @returns {number} Byte length of buffer.\n   */ get byteLength() {\n        return this.#buffer.byteLength;\n    }\n    /**\n   * Get current read pointer.\n   *\n   * @returns {number} Internal read pointer.\n   */ get readPointer() {\n        return this.#readPointer;\n    }\n    /**\n   * Safely set current read pointer, observing bit size of buffer.\n   *\n   * @param {number} pointer - Updated read pointer.\n   * @returns {void}\n   */ set readPointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) return;\n        // Update internal pointer.\n        this.#readPointer = pointer;\n    }\n    /**\n   * Get last read size in bits.\n   *\n   * @returns {number} Internal last read size in bits.\n   */ get lastReadSize() {\n        return this.#lastReadSize;\n    }\n    /**\n   * Safely set last read size, observing max and min integer bit sizes.\n   *\n   * @param {number} size - Updated last read size in bits.\n   * @returns {void}\n   */ set lastReadSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) return;\n        // Update internal read size.\n        this.#lastReadSize = size;\n    }\n    /**\n   * Get current write pointer.\n   *\n   * @returns {number} Internal write pointer.\n   */ get writePointer() {\n        return this.#writePointer;\n    }\n    /**\n   * Safely set current write pointer, observing bit size of buffer.\n   *\n   * @param {number} pointer - Updated write pointer.\n   * @returns {void}\n   */ set writePointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) return;\n        // Update internal pointer.\n        this.#writePointer = pointer;\n    }\n    /**\n   * Get last write size in bits.\n   *\n   * @returns {number} Internal last write size in bits.\n   */ get lastWriteSize() {\n        return this.#lastWriteSize;\n    }\n    /**\n   * Safely set last write size, observing max and min integer bit sizes.\n   *\n   * @param {number} size - Updated last write size in bits.\n   * @returns {void}\n   */ set lastWriteSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) return;\n        // Update internal write size.\n        this.#lastWriteSize = size;\n    }\n    /**\n   * Decode serialized url-safe base 64 BitBuffer string, returning a new\n   * BitBuffer instance containing the data from the original serialized\n   * buffer.\n   *\n   * @param {string} string - Url-safe base 64 encoded BitBuffer string.\n   * @returns {BitBuffer} Decoded BitBuffer instance.\n   */ static from(string) {\n        // Throw error if input string not correctly encoded.\n        if (!string.match(/^[A-Za-z0-9\\-_]*$/)) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"BitBufferError\",\n            message: \"Encoded string is not url-safe base 64 encoded\",\n            \"encoded-string\": string\n        });\n        // Create new BitBuffer instance based on length of input string.\n        const buffer = new $025fa45280fd44fb$export$4f347c1cf22bbd8({\n            size: Math.ceil(string.length * 3 / 4)\n        });\n        // Split input string into 4-character segments, convert each segment\n        // into 24-bit unsigned integer, and write to new BitBuffer instance.\n        const regex = /[A-Za-z0-9\\-_]{1,4}/g;\n        for (const match of string.match(regex) || []){\n            const uint24 = $025fa45280fd44fb$export$4f347c1cf22bbd8.#b64ToUint24(match.padEnd(4, \"A\"));\n            buffer.write(uint24, {\n                size: 24\n            });\n        }\n        // Reset read and write pointers.\n        buffer.writePointer = 0;\n        buffer.readPointer = 0;\n        return buffer;\n    }\n    /**\n   * Convert 4 character url-safe base 64 string to 24-bit unsigned integer.\n   *\n   * @param {string} string - 4 character url-safe base 64 string.\n   * @returns {number} Unsigned 24 bit integer.\n   */ static #b64ToUint24(string) {\n        let uint24 = 0;\n        // Loop over characters of input string, converting each url-safe base\n        // 64 character to a 6-bit integer. Bitwise SHIFT the result such that\n        // the 6 data bits occupy a unique sector of the uint24 output, and\n        // bitwise AND the result with the uint24 output.\n        for (const [index, char] of string.split(\"\").entries()){\n            const uint6 = $025fa45280fd44fb$export$4f347c1cf22bbd8.#dict.indexOf(char);\n            uint24 = (uint24 | uint6 << 18 - index * 6) >>> 0;\n        }\n        return uint24;\n    }\n    /**\n   * Convert 24-bit unsigned integer to 4 character url-safe base 64 string.\n   *\n   * @param {number} uint24 - Unsigned 24 bit integer.\n   * @returns {string} 4 character url-safe base 64 string.\n   */ static #uint24ToB64(uint24) {\n        let string = \"\";\n        // Divide 24-bit integer into 6-bit segments, appending a url-safe base\n        // 64 character to output string for each segment.\n        for(let i = 0; i < 4; i++){\n            const uint6 = uint24 >>> 18 - i * 6 << 26 >>> 26;\n            string += $025fa45280fd44fb$export$4f347c1cf22bbd8.#dict[uint6];\n        }\n        return string;\n    }\n    /**\n   * Get bit length of a given number.\n   *\n   * @param {number} value - Input number.\n   * @returns {number} Bit length.\n   */ static #bitLength(value) {\n        return Math.abs(value).toString(2).length;\n    }\n    /**\n   * Get url-safe base64 character dictionary, which uses different padding\n   * characters to the standard base64 encoding in node. Please see\n   * [here](https://developer.mozilla.org/en-US/docs/Glossary/Base64) for more\n   * information on base64 encoding. For url safe characters, see rfc4648\n   * [here](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n   *\n   * @returns {string} Url-safe base64 dictionary string.\n   */ static get #dict() {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"; // Url-safe padding characters for total of 64 characters.\n    }\n}\n\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Class for managing multiple workers up to a specified limit.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n// note that shared workers are not possible due to not being currently\n// available in chrome for android https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker @no-wrap\nclass $86e52ea92617c364$export$bcff6015853c67ce {\n    #queue = /** @type {{message:any, callback:(event:any)=>void}[]} */ [];\n    #workers = /** @type {Map.<Worker, number>} */ new Map();\n    #instantiateWorker;\n    #limit;\n    /**\n   *\n   * @param {()=>Worker} callback\n   * @param {object} obj\n   * @param {number} [obj.limit]\n   */ constructor(callback, { limit: limit = 4 } = {}){\n        this.#instantiateWorker = callback;\n        this.#limit = limit;\n    }\n    /**\n   *\n   * @returns {Worker}\n   */ addWorker() {\n        const worker = this.#instantiateWorker();\n        this.#workers.set(worker, NaN);\n        return worker;\n    }\n    /**\n   *\n   * @param {Worker} worker\n   * @param {any} message\n   * @param {(event:any)=>void} callback\n   */ postWorker(worker, message, callback) {\n        this.#workers.set(worker, NaN);\n        worker.onmessage = (event)=>{\n            this.#dequeue(worker);\n            callback(event);\n        };\n        worker.postMessage(message);\n    }\n    /**\n   *\n   * @param {any} message\n   * @param {(event:any)=>void} callback\n   */ enqueue(message, callback) {\n        let /** @type {Worker|undefined} */ worker;\n        for (const [existingWorker, timeLastActive] of this.#workers)if (timeLastActive) {\n            worker = existingWorker;\n            break;\n        }\n        if (worker) this.postWorker(worker, message, callback);\n        else if (this.#workers.size < this.#limit) {\n            worker = this.addWorker();\n            this.postWorker(worker, message, callback);\n        } else this.#queue.push({\n            message: message,\n            callback: callback\n        });\n    }\n    /**\n   *\n   * @param {Worker} worker\n   */ #dequeue(worker) {\n        const { message: message, callback: callback } = this.#queue.shift() || {};\n        if (message && callback) this.postWorker(worker, message, callback);\n        else {\n            this.#workers.set(worker, Date.now());\n            setTimeout(()=>{\n                const timeLastActive = /** @type {number} */ this.#workers.get(worker);\n                if (Date.now() - timeLastActive > 1000) {\n                    worker.terminate();\n                    this.#workers.delete(worker);\n                }\n            }, 1050);\n        }\n    }\n}\n\n\n\n\n// @@body\nclass $b25947ab9039cbe8$export$15fcc258e19c8efc {\n    #luma;\n    #chromaBlue;\n    #chromaRed;\n    #total;\n    /**\n   *\n   * @param {string} subsampling\n   */ constructor(subsampling){\n        //\n        const { luma: luma, chromaBlue: chromaBlue, chromaRed: chromaRed } = subsampling.match(/^(?<luma>[0-7]):(?<chromaBlue>[0-7]):(?<chromaRed>[0-7])$/)?.groups || {};\n        //\n        if (!luma || !chromaBlue || !chromaRed) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"SubsamplingError\",\n            message: 'Must be of form \"x:y:z\", digits from 0-7 inclusive',\n            \"subsampling-string\": subsampling\n        });\n        //\n        this.#luma = parseInt(luma);\n        this.#chromaBlue = parseInt(chromaBlue);\n        this.#chromaRed = parseInt(chromaRed);\n        this.#total = this.#luma + this.#chromaBlue + this.#chromaRed;\n    }\n    /**\n   *\n   * @param {number} index\n   * @returns {\"luma\"|\"chromaBlue\"|\"chromaRed\"}\n   */ key(index) {\n        //\n        const subsample = index % this.#total;\n        //\n        return subsample < this.#luma ? \"luma\" : subsample < this.#luma + this.#chromaBlue ? \"chromaBlue\" : \"chromaRed\";\n    }\n    get luma() {\n        return this.#luma;\n    }\n    get chromaBlue() {\n        return this.#chromaBlue;\n    }\n    get chromaRed() {\n        return this.#chromaRed;\n    }\n}\n\n\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n// build dct coefficients\n/**\n *\n * @param {number} width\n * @param {number} height\n * @param {SubsampleSelector} subsampleSelector\n */ function* $95222a7a04e259da$export$662ff58f84a04efc(width, height, subsampleSelector) {\n    const builders = {\n        luma: $95222a7a04e259da$var$buildDctArray2D(width, height),\n        chromaBlue: $95222a7a04e259da$var$buildDctArray2D(width, height),\n        chromaRed: $95222a7a04e259da$var$buildDctArray2D(width, height)\n    };\n    const array3D = [\n        builders.luma.next().value,\n        builders.chromaBlue.next().value,\n        builders.chromaRed.next().value\n    ];\n    let index = 0;\n    do {\n        const value = /** @type {number} */ yield array3D;\n        const key = subsampleSelector.key(index);\n        const iteration = builders[key].next(value);\n        if (iteration.done) break;\n        key === \"luma\" ? array3D[0] = iteration.value : key === \"chromaBlue\" ? array3D[1] = iteration.value : array3D[2] = iteration.value;\n    }while (++index);\n}\n// build 2d array from diagonal\n/**\n *\n * @param {number} width\n * @param {number} height\n */ function* $95222a7a04e259da$var$buildDctArray2D(width, height) {\n    // /** @type {number[][]} */\n    // const array2D = Array.from(\n    //     Array.from({ length: height }),\n    //     () => Array.from({ length: width }).fill(0)\n    // )\n    const array2D = Array.from(Array.from({\n        length: width\n    }), ()=>Array.from({\n            length: height\n        }).fill(0));\n    let [x, y] = [\n        0,\n        0\n    ];\n    while(true){\n        // array2D[y][x] = /** @type {number} */ (yield array2D)\n        array2D[x][y] = /** @type {number} */ yield array2D;\n        if (y === 0 || x === width - 1) {\n            const sum = x + y + 1;\n            if (sum > width + height - 1) break;\n            y = x >= height - 1 ? height - 1 : x + 1;\n            x = sum - y;\n        } else {\n            y--;\n            x++;\n        }\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Colorspace conversions for jpg dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n * Clamp and optionally round input number between a minimum and maximum value.\n *\n * @param {number} number - Input number.\n * @param {number} minimum - Minimum value which will be returned.\n * @param {number} maximum - Maximum value which will be returned.\n * @param {boolean} isInt - Should returned value be an integer?\n * @returns {number} Clamped value.\n */ const $05e2715665d4e47d$var$clamp = (number, minimum = 0, maximum = 255, isInt = true)=>{\n    // If should return integer, round arguments whilst respecting maximum and\n    // minimum sense of bounds (i.e. do not round minimum down or maximum up\n    // which allows numbers to be returned outside of clamp bounds).\n    if (isInt) {\n        number = Math.round(number);\n        minimum = Math.ceil(minimum);\n        maximum = Math.floor(maximum);\n    }\n    // Return clamped number.\n    return Math.max(minimum, Math.min(maximum, number));\n};\n/**\n * Convert rgb (red, green, blue) color value to YCbCr (luma, chroma blue,\n * chroma red) color value for use in jpg dct compression. Please see [this\n * section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} red - Red value of color between 0 and 255.\n * @param {number} green - Green value of color between 0 and 255.\n * @param {number} blue - Blue value of color between 0 and 255.\n * @returns {{luma:number, chromaBlue:number, chromaRed:number}} Color converted\n *      to YCbCr.\n */ const $05e2715665d4e47d$export$251193c44da375d8 = (red, green, blue)=>{\n    // Clamp input channels to values between 0 and 255.\n    red = $05e2715665d4e47d$var$clamp(red);\n    green = $05e2715665d4e47d$var$clamp(green);\n    blue = $05e2715665d4e47d$var$clamp(blue);\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        luma: $05e2715665d4e47d$var$clamp(0.30 * red + 0.59 * green + 0.11 * blue),\n        chromaBlue: $05e2715665d4e47d$var$clamp(128 - 0.17 * red - 0.33 * green + 0.50 * blue),\n        chromaRed: $05e2715665d4e47d$var$clamp(128 + 0.50 * red - 0.42 * green - 0.08 * blue)\n    };\n};\n/**\n * Convert 4-channel rgba (red, green, blue, alpha) buffer into a 3-channel\n * YCbCr (luma, chroma blue, chroma red) flat data array.\n *\n * @param {Buffer} rgbaBuffer - 4-channel, rgba formatted buffer.\n * @returns 3-channel, YCbCr formatted flat data array.\n */ const $05e2715665d4e47d$export$64581645ccce9ef7 = (rgbaBuffer)=>{\n    // Initialise flat output data array.\n    const yCbCrArray = [];\n    // Loop over input data array, fetching the luma, chroma blue, and chroma\n    // red values from the red, green, and blue input data values. Skip alpha\n    // channel, and push converted pixel data to the output array.\n    for(let i = 0; i < rgbaBuffer.length; i += 4){\n        const { luma: luma, chromaBlue: chromaBlue, chromaRed: chromaRed } = $05e2715665d4e47d$export$251193c44da375d8(rgbaBuffer[i], rgbaBuffer[i + 1], rgbaBuffer[i + 2]);\n        yCbCrArray.push(luma, chromaBlue, chromaRed);\n    }\n    return yCbCrArray;\n};\n/**\n * Convert YCbCr (luma, chroma blue, chroma red) color value to rgb (red, green,\n * blue) color value for use in reversing colorspace used in jpg dct. Please see\n * [this section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} luma - Luma value of color between 0 and 255.\n * @param {number} chromaBlue - Chroma blue value of color between 0 and 255.\n * @param {number} chromaRed - Chroma red value of color between 0 and 255.\n * @returns {{red:number, green:number, blue:number}} Color converted to rgb.\n */ const $05e2715665d4e47d$export$f8d5c49fa675945f = (luma, chromaBlue, chromaRed)=>{\n    // Clamp input channels to values between 0 and 255.\n    luma = $05e2715665d4e47d$var$clamp(luma);\n    chromaBlue = $05e2715665d4e47d$var$clamp(chromaBlue);\n    chromaRed = $05e2715665d4e47d$var$clamp(chromaRed);\n    // Rectify chroma values such that they are between -128 and +128.\n    chromaBlue -= 128;\n    chromaRed -= 128;\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        red: $05e2715665d4e47d$var$clamp(luma + 1.40 * chromaRed),\n        green: $05e2715665d4e47d$var$clamp(luma - 0.34 * chromaBlue - 0.71 * chromaRed),\n        blue: $05e2715665d4e47d$var$clamp(luma + 1.77 * chromaBlue)\n    };\n};\n/**\n * Convert 3-channel YCbCr (luma, chroma blue, chroma red) flat data array into\n * 4-channel rgba (red, green, blue, alpha) flat data array.\n *\n * @param {number[]} yCbCrArray - 3-channel, YCbCr formatted flat data array.\n * @returns 4-channel, rgba formatted flat data array.\n */ const $05e2715665d4e47d$export$8bc460b4baf863e7 = (yCbCrArray, alpha = 255)=>{\n    // Initialise flat output data array.\n    const rgbaArray = [];\n    // Loop over input data array, fetching the red, green, and blue values from\n    // the luma, chroma blue, and chroma red input data values. Push converted\n    // pixel data to the output array with extra alpha channel.\n    for(let i = 0; i < yCbCrArray.length; i += 3){\n        const { red: red, green: green, blue: blue } = $05e2715665d4e47d$export$f8d5c49fa675945f(yCbCrArray[i], yCbCrArray[i + 1], yCbCrArray[i + 2]);\n        rgbaArray.push(red, green, blue, alpha);\n    }\n    return rgbaArray;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Methods for decoding pixel arrays using dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */ \n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n/**\n *\n * @param {number[][][]} array3D\n * @param {BlurridMetadata} metadata\n * @returns {number[][][]}\n */ const $0525f6702f01f430$export$b24f58bb0238ca0c = (array3D, metadata)=>{\n    const [lumaDct, chromaBlueDct, chromaRedDct] = array3D;\n    const emptyChannel = ()=>{\n        return Array.from(Array.from({\n            length: metadata.image.height\n        }), ()=>Array.from({\n                length: metadata.image.width\n            }).fill(0));\n    };\n    const channels = [\n        emptyChannel(),\n        emptyChannel(),\n        emptyChannel()\n    ];\n    const [lumaChannel, chromaBlueChannel, chromaRedChannel] = channels;\n    for(let y = 0; y < metadata.image.height; y++)for(let x = 0; x < metadata.image.width; x++){\n        const point = {\n            x: x / metadata.image.width * metadata.sample.width,\n            y: y / metadata.image.height * metadata.sample.height\n        };\n        lumaChannel[y][x] = $0525f6702f01f430$var$decodePixelArray2D(lumaDct, point, metadata);\n        chromaBlueChannel[y][x] = $0525f6702f01f430$var$decodePixelArray2D(chromaBlueDct, point, metadata);\n        chromaRedChannel[y][x] = $0525f6702f01f430$var$decodePixelArray2D(chromaRedDct, point, metadata);\n    }\n    return channels;\n};\n/**\n *\n * @param {number[][]} array2D\n * @param {{x:number, y:number}} point\n * @param {BlurridMetadata} metadata\n * @returns\n */ const $0525f6702f01f430$var$decodePixelArray2D = (array2D, point, metadata)=>{\n    const dctRow = [];\n    for(let i = 0; i < metadata.sample.width; i++){\n        const dctColumn = array2D[i];\n        dctRow.push($0525f6702f01f430$var$decodePixelArray1D(dctColumn, point.y));\n    }\n    return $0525f6702f01f430$var$decodePixelArray1D(dctRow, point.x);\n};\n// note in this implementation radians is always supplied +ve\n/**\n *\n * @param {number} radians - Angle value in radians, note that in this\n *      implementation the angle is *always* provided as a positive value.\n * @returns {number}\n */ const $0525f6702f01f430$var$fastCos = (radians)=>{\n    // Rectify angle value to between 0 and 2PI radians using custom mod (while\n    // loop faster than builtin javascript `%` mod operator)\n    while(radians >= Math.PI * 2)radians -= Math.PI * 2;\n    // Rectify angle value to between 0 and PI radians (note that since angle\n    // value is *always* supplied as a positive value in this implementation,\n    // rectifying to a positive value is not required).\n    if (radians > Math.PI) radians = 2 * Math.PI - radians;\n    // Execute fastCos formula using a rearranged Bhaskara sine approximation\n    // (see here for more https://en.wikipedia.org/wiki/Bh%C4%81skara_I%27s_sine_approximation_formula) @no-wrap\n    if (radians > Math.PI / 2) {\n        radians = (radians - Math.PI) * (radians - Math.PI);\n        return 5 * radians / (radians + Math.PI * Math.PI) - 1;\n    }\n    radians *= radians;\n    return 1 - 5 * radians / (radians + Math.PI * Math.PI);\n};\n/**\n *\n * @param {number[]} array1D\n * @param {number} pointX\n * @returns {number}\n */ const $0525f6702f01f430$var$decodePixelArray1D = (array1D, pointX)=>{\n    let result = 0;\n    for(let i = 0; i < array1D.length; i++){\n        let partial = array1D[i] * $0525f6702f01f430$var$fastCos((2 * pointX + 1) * Math.PI * i / (2 * array1D.length));\n        partial *= i === 0 ? Math.SQRT1_2 : 1;\n        result += partial;\n    }\n    result *= Math.sqrt(2 / array1D.length);\n    result = Math.round(result);\n    return result;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Global variables for buffer start locations for certain data.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\nconst $e080c59fbd4e2b99$export$a0d7c623ebd339f3 = {\n    METADATA: 0,\n    SUBSAMPLING: 48,\n    COEFFICIENTS: 57,\n    ASSUMED_COEFFICIENT_SIZE: 8\n};\n\n\n\n\n// @@body\nclass $7285f96793324acb$export$a17c6f6fb2637705 {\n    #serializedDct;\n    #buffer;\n    #metadata;\n    #coefficients;\n    /**\n   *\n   * @param {string} serializedDct\n   */ constructor(serializedDct){\n        // absolute minimum 10\n        if (!serializedDct.match(/^[A-Za-z0-9\\-_]{16,}$/)) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"BlurridDecoderError\",\n            message: \"String minimum 16 url-safe base 64 encoded chars\",\n            \"serialized-dct\": serializedDct\n        });\n        this.#serializedDct = serializedDct;\n        this.#buffer = (0, $025fa45280fd44fb$export$4f347c1cf22bbd8).from(serializedDct);\n        this.#metadata = new (0, $04f5c56647ae8c40$export$a343f46e34a234f1)(this.#deserializeMetadata());\n        this.#coefficients = this.#deserializeCoefficients();\n    }\n    toImageData() {\n        const { luma: luma, chromaBlue: chromaBlue, chromaRed: chromaRed } = this.#coefficients;\n        const array3D = [\n            luma,\n            chromaBlue,\n            chromaRed\n        ];\n        return (0, $05e2715665d4e47d$export$8bc460b4baf863e7)((0, $931f6948e16b2f88$export$c28500e84d42e56e)((0, $0525f6702f01f430$export$b24f58bb0238ca0c)(array3D, this.#metadata)));\n    }\n    #deserializeMetadata() {\n        //\n        this.#buffer.readPointer = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).METADATA;\n        //\n        const image = {\n            width: this.#buffer.read(16),\n            height: this.#buffer.read(16)\n        };\n        const sample = {\n            width: this.#buffer.read(8),\n            height: this.#buffer.read(8)\n        };\n        return {\n            image: image,\n            sample: sample\n        };\n    }\n    #deserializeSubsampling() {\n        //\n        this.#buffer.readPointer = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).SUBSAMPLING;\n        const luma = this.#buffer.read(3);\n        const chromaBlue = this.#buffer.read(3);\n        const chromaRed = this.#buffer.read(3);\n        return new (0, $b25947ab9039cbe8$export$15fcc258e19c8efc)(`${luma}:${chromaBlue}:${chromaRed}`);\n    }\n    #deserializeCoefficients() {\n        const dctBuilder = this.#dctBuilder();\n        let [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */ dctBuilder.next().value;\n        //\n        this.#buffer.readPointer = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).COEFFICIENTS;\n        this.#buffer.lastReadSize = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).ASSUMED_COEFFICIENT_SIZE;\n        /* eslint-disable-next-line no-constant-condition -- break from in while\n    loop ends loop. */ while(true){\n            const coefficient = this.#buffer.readRelative({\n                signed: true\n            });\n            if (isNaN(coefficient)) break;\n            // check if done, and break\n            [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */ dctBuilder.next(coefficient).value;\n        }\n        return {\n            luma: luma,\n            chromaBlue: chromaBlue,\n            chromaRed: chromaRed\n        };\n    }\n    #dctBuilder() {\n        //\n        return (0, $95222a7a04e259da$export$662ff58f84a04efc)(this.#metadata.sample.width, this.#metadata.sample.height, this.#deserializeSubsampling());\n    }\n    get serializedDct() {\n        return this.#serializedDct;\n    }\n    get metadata() {\n        return this.#metadata;\n    }\n    get coefficients() {\n        return this.#coefficients;\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Wrapper class around blurrid dct encoding functions.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Generator for consuming arrays of dct coefficients.\n * @author James Reid\n */ // @ts-check\n// @@imports-utils\n\n\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n/**\n *\n * @param {number[][][]} array3D\n * @param {SubsampleSelector} subsampleSelector\n */ function* $d2b8c6b909802a11$export$87f57c01aa7490fe(array3D, subsampleSelector) {\n    const [lumaArray2D, chromaBlueArray2D, chromaRedArray2D] = array3D;\n    const consumers = {\n        luma: $d2b8c6b909802a11$var$consumeDctArray2D(lumaArray2D),\n        chromaBlue: $d2b8c6b909802a11$var$consumeDctArray2D(chromaBlueArray2D),\n        chromaRed: $d2b8c6b909802a11$var$consumeDctArray2D(chromaRedArray2D)\n    };\n    let index = 0;\n    do {\n        const iteration = consumers[subsampleSelector.key(index)].next();\n        if (iteration.done) break;\n        yield iteration.value;\n    }while (++index);\n}\n// consume 2d array from diagonal\n/**\n *\n * @param {number[][]} array2D - 2D array of dct coefficients (the 2D array will\n *      be one subsample\n *      from luma, or each chrominance).\n */ function* $d2b8c6b909802a11$var$consumeDctArray2D(array2D) {\n    const [width, height] = [\n        array2D[0].length,\n        array2D.length\n    ];\n    for (const coefficientRow of array2D){\n        if (coefficientRow.length !== width) throw new (0, $365a44e770a0b11c$export$39785c5d1570d2b1)({\n            name: \"DctError\",\n            message: \"Coefficient row width does not match image width\",\n            \"image-width\": length,\n            \"row-width\": coefficientRow.length\n        });\n    }\n    let [x, y] = [\n        0,\n        0\n    ];\n    while(true){\n        yield array2D[y][x];\n        if (y === 0 || x === width - 1) {\n            const sum = x + y + 1;\n            if (sum > width + height - 2) break;\n            y = x >= height - 1 ? height - 1 : x + 1;\n            x = sum - y;\n        } else {\n            y--;\n            x++;\n        }\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Methods for encoding pixel arrays using dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n *\n * @param {number[][][]} array3D\n * @returns {number[][][]}\n */ const $bda713b108a818d7$export$e4d27daeadfd0641 = (array3D)=>{\n    return array3D.map($bda713b108a818d7$var$encodePixelArray2D);\n};\n/**\n * add errors for inconsistent widths\n *\n * @param {number[][]} array2D\n * @returns {number[][]}\n */ const $bda713b108a818d7$var$encodePixelArray2D = (array2D)=>{\n    /** @type {number[][]} */ const primaryEncodedArray2D = [];\n    for(let i = 0; i < array2D.length; i++)primaryEncodedArray2D.push($bda713b108a818d7$var$encodePixelArray1D(array2D[i]));\n    /** @type {number[][]} */ const secondaryEncodedArray2D = Array.from(Array.from({\n        length: primaryEncodedArray2D.length\n    }), ()=>[]);\n    for(let i = 0; i < primaryEncodedArray2D[0].length; i++){\n        const column = [];\n        for(let j = 0; j < primaryEncodedArray2D.length; j++)column.push(primaryEncodedArray2D[j][i]);\n        for (const [j, coefficient] of $bda713b108a818d7$var$encodePixelArray1D(column).entries())secondaryEncodedArray2D[j].push(coefficient);\n    }\n    return secondaryEncodedArray2D;\n};\n/**\n *\n * @param {number[]} array1D\n * @returns {number[]}\n */ const $bda713b108a818d7$var$encodePixelArray1D = (array1D)=>{\n    const coefficients = [];\n    for(let i = 0; i < array1D.length; i++){\n        let coefficient = 0;\n        for(let j = 0; j < array1D.length; j++)coefficient += array1D[j] * Math.cos((2 * j + 1) * Math.PI * i / (2 * array1D.length));\n        coefficient *= Math.sqrt(2 / array1D.length);\n        coefficient *= i === 0 ? Math.sqrt(0.5) : 1;\n        coefficients.push(Math.round(coefficient));\n    }\n    return coefficients;\n};\n\n\n\n\n\n// @@body\nclass $dbe93a6d1cd2d5eb$export$513aa7ae53930a4d {\n    #metadata;\n    #buffer;\n    /**\n   *\n   * @param {object} obj\n   * @param {Buffer} obj.buffer\n   * @param {number} obj.width\n   * @param {number} obj.height\n   */ constructor({ buffer: buffer, width: width, height: height }){\n        const ratio = Math.min(width, height) / Math.max(width, height);\n        const samples = Math.round(Math.sqrt(buffer.length / (4 * ratio)));\n        const secondarySamples = buffer.length / 4 / samples;\n        const { sampleWidth: sampleWidth, sampleHeight: sampleHeight } = width > height ? {\n            sampleWidth: samples,\n            sampleHeight: secondarySamples\n        } : {\n            sampleWidth: secondarySamples,\n            sampleHeight: samples\n        };\n        const image = {\n            width: width,\n            height: height\n        };\n        const sample = {\n            width: sampleWidth,\n            height: sampleHeight\n        };\n        this.#metadata = new (0, $04f5c56647ae8c40$export$a343f46e34a234f1)({\n            image: image,\n            sample: sample\n        });\n        this.#buffer = buffer;\n    }\n    toString({ length: length = 64, subsampling: subsampling = \"4:2:2\" } = {}) {\n        //\n        const buffer = new (0, $025fa45280fd44fb$export$4f347c1cf22bbd8)({\n            length: length\n        });\n        const subsampleSelector = new (0, $b25947ab9039cbe8$export$15fcc258e19c8efc)(subsampling);\n        //\n        this.#serializeMetadata(buffer);\n        this.#serializeSubsampling(buffer, subsampleSelector);\n        this.#serializeCoefficients(buffer, subsampleSelector);\n        return buffer.toString();\n    }\n    /**\n   *\n   * @param {BitBuffer} buffer\n   */ #serializeMetadata(buffer) {\n        //\n        buffer.writePointer = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).METADATA;\n        //\n        buffer.write(this.#metadata.image.width, {\n            size: 16\n        });\n        buffer.write(this.#metadata.image.height, {\n            size: 16\n        });\n        buffer.write(this.#metadata.sample.width, {\n            size: 8\n        });\n        buffer.write(this.#metadata.sample.height, {\n            size: 8\n        });\n    }\n    /**\n   *\n   * @param {BitBuffer} buffer\n   * @param {SubsampleSelector} subsampleSelector\n   */ #serializeSubsampling(buffer, subsampleSelector) {\n        //\n        buffer.writePointer = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).SUBSAMPLING;\n        buffer.write(subsampleSelector.luma, {\n            size: 3\n        });\n        buffer.write(subsampleSelector.chromaBlue, {\n            size: 3\n        });\n        buffer.write(subsampleSelector.chromaRed, {\n            size: 3\n        });\n    }\n    /**\n   *\n   * @param {BitBuffer} buffer\n   * @param {SubsampleSelector} subsampleSelector\n   */ #serializeCoefficients(buffer, subsampleSelector) {\n        //\n        buffer.writePointer = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).COEFFICIENTS;\n        buffer.lastWriteSize = (0, $e080c59fbd4e2b99$export$a0d7c623ebd339f3).ASSUMED_COEFFICIENT_SIZE;\n        for (const coefficient of this.#dctConsumer(subsampleSelector)){\n            const written = buffer.writeRelative(coefficient, {\n                signed: true\n            });\n            if (isNaN(written)) break;\n        }\n    }\n    /**\n   *\n   * @param {SubsampleSelector} subsampleSelector\n   * @returns\n   */ #dctConsumer(subsampleSelector) {\n        const yCbCrArray = (0, $05e2715665d4e47d$export$64581645ccce9ef7)(this.#buffer);\n        const array3D = (0, $931f6948e16b2f88$export$b0d6d19929940a93)(yCbCrArray, this.#metadata.sample.width);\n        return (0, $d2b8c6b909802a11$export$87f57c01aa7490fe)((0, $bda713b108a818d7$export$e4d27daeadfd0641)(array3D), subsampleSelector);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Export shader methods for generating image blur placeholders on web.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@no-body\n// @@exports\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Methods for generating webgl and context2d canvas elements.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n// @ts-expect-error: File is a glsl shader which will be loaded by rollup.\nvar $7396a80ccdef2400$exports = {};\n$7396a80ccdef2400$exports = \"#define GLSLIFY 1\\nattribute vec4 a_position;\\n\\nvoid main() {\\n    gl_Position = a_position;\\n}\\n\";\n\n\nvar $f8fa4ba9caed0201$exports = {};\n$f8fa4ba9caed0201$exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec4 u_color;\\nuniform float u_image_width;\\nuniform float u_image_height;\\n\\nuniform float u_lumaDct[{{SAMPLE_NORMALIZED_TOTAL}}];\\nuniform float u_chromaBlueDct[{{SAMPLE_NORMALIZED_TOTAL}}];\\nuniform float u_chromaRedDct[{{SAMPLE_NORMALIZED_TOTAL}}];\\n\\nfloat kFactor(int x) {\\n    if (x == 0) { return 0.7071; }\\n    else { return 1.0; }\\n}\\n\\nfloat decode1D(float array1D[{{SAMPLE_MAX}}], float point, int samples) {\\n    float float_samples = float(samples);\\n\\n    float result = 0.0;\\n\\n    for (int i = 0; i < {{SAMPLE_MAX}}; i ++) {\\n        if (float(array1D[i]) == 0.0 || i >= samples) { break; }\\n\\n        float partial = float(array1D[i]) * cos(\\n            ((2.0 * point + 1.0) * 3.14 * float(i)) / (2.0 * float_samples)\\n        );\\n\\n        partial *= kFactor(i);\\n        result += partial;\\n    }\\n\\n    result *= sqrt(2.0 / float_samples);\\n\\n    return result;\\n}\\n\\nfloat decode2D(float array2D[{{SAMPLE_NORMALIZED_TOTAL}}], vec2 uv) {\\n    float row[{{SAMPLE_MAX}}];\\n\\n    float x = uv.x * {{SAMPLE_WIDTH}}.0;\\n    float y = (1.0 - uv.y) * {{SAMPLE_HEIGHT}}.0;\\n\\n    for (int i = 0; i < {{SAMPLE_MAX}}; i ++) {\\n        float column[{{SAMPLE_MAX}}];\\n        for (int j = 0; j < {{SAMPLE_MAX}}; j ++) {\\n            column[j] = array2D[i * {{SAMPLE_MAX}} + j];\\n        }\\n        row[i] = decode1D(column, y, {{SAMPLE_HEIGHT}});\\n    }\\n\\n    float result = decode1D(row, x, {{SAMPLE_WIDTH}});\\n\\n    return result;\\n}\\n\\nvec4 yCbCrToRgb(float luma, float chromaBlue, float chromaRed) {\\n    //\\n    float red = luma + 1.40 * (chromaRed - 128.0);\\n    float green = luma - 0.34 * (chromaBlue - 128.0) - 0.71 * (chromaRed - 128.0);\\n    float blue = luma + 1.77 * (chromaBlue - 128.0);\\n\\n    //\\n    red = floor(clamp(red, 0.0, 255.0) + 0.5) / 255.0;\\n    green = floor(clamp(green, 0.0, 255.0) + 0.5) / 255.0;\\n    blue = floor(clamp(blue, 0.0, 255.0) + 0.5) / 255.0;\\n\\n    return vec4(red, green, blue, 1.0);\\n}\\n\\nvoid main() {\\n    //\\n    vec2 uv = gl_FragCoord.xy;\\n    uv.x /= u_image_width;\\n    uv.y /= u_image_height;\\n\\n    //\\n    gl_FragColor = yCbCrToRgb(\\n        decode2D(u_lumaDct, uv),\\n        decode2D(u_chromaBlueDct, uv),\\n        decode2D(u_chromaRedDct, uv)\\n    );\\n}\\n\";\n\n\n\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n/**\n *\n * @param {BlurridMetadata} metadata\n * @returns {{canvas:HTMLCanvasElement, context:WebGLRenderingContext, program:WebGLProgram}} @no-wrap\n */ const $b4fab70876281105$export$10c7fe55c4ed3d74 = (metadata)=>{\n    //\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = metadata.image.width;\n    canvas.height = metadata.image.height;\n    //\n    const context = /** @type {WebGLRenderingContext} */ canvas.getContext(\"webgl\");\n    const shaders = {\n        vertex: $b4fab70876281105$var$getShader(context, context.VERTEX_SHADER, (0, (/*@__PURE__*/$parcel$interopDefault($7396a80ccdef2400$exports)))),\n        fragment: $b4fab70876281105$var$getShader(context, context.FRAGMENT_SHADER, (0, (/*@__PURE__*/$parcel$interopDefault($f8fa4ba9caed0201$exports))), {\n            SAMPLE_WIDTH: metadata.sample.width,\n            SAMPLE_HEIGHT: metadata.sample.height,\n            SAMPLE_MAX: metadata.sample.max,\n            SAMPLE_NORMALIZED_TOTAL: metadata.sample.max ** 2\n        })\n    };\n    const program = $b4fab70876281105$var$getProgram(context, shaders);\n    const vertexData = {\n        index: context.getAttribLocation(program, \"a_position\"),\n        // Location of position attributes. @no-wrap\n        size: 2,\n        // 2 components (triangles) per iteration.\n        type: context.FLOAT,\n        // Data expected as 32-bit floats.\n        normalize: false,\n        // Don't normalise data.\n        stride: 0,\n        // 0 = move forward size * sizeof(type) each iteration to get the next position @no-wrap\n        offset: 0 // Start at beginning of buffer\n    };\n    const positionBuffer = context.createBuffer();\n    context.bindBuffer(context.ARRAY_BUFFER, positionBuffer);\n    // triangle positions for drawing entire grid\n    const positions = [\n        -1,\n        1,\n        1,\n        1,\n        1,\n        -1,\n        1,\n        -1,\n        -1,\n        -1,\n        -1,\n        1\n    ];\n    context.bufferData(context.ARRAY_BUFFER, new Float32Array(positions), context.STATIC_DRAW);\n    context.clearColor(0, 0, 0, 0);\n    context.clear(context.COLOR_BUFFER_BIT);\n    context.useProgram(program);\n    context.enableVertexAttribArray(vertexData.index);\n    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    const { index: index, size: size, type: type, normalize: normalize, stride: stride, offset: offset } = vertexData;\n    context.vertexAttribPointer(index, size, type, normalize, stride, offset);\n    return {\n        canvas: canvas,\n        context: context,\n        program: program\n    };\n};\n/**\n *\n * @param {BlurridMetadata} metadata\n * @returns {{canvas:HTMLCanvasElement, context:CanvasRenderingContext2D}}\n */ const $b4fab70876281105$export$7bfb6a10627b78e8 = (metadata)=>{\n    //\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = metadata.image.width;\n    canvas.height = metadata.image.height;\n    //\n    const context = /** @type {CanvasRenderingContext2D} */ canvas.getContext(\"2d\");\n    return {\n        canvas: canvas,\n        context: context\n    };\n};\n/**\n *\n * @param {WebGLRenderingContext} context\n * @param {{vertex:WebGLShader, fragment:WebGLShader}} shaders\n * @returns {WebGLProgram}\n */ const $b4fab70876281105$var$getProgram = (context, shaders)=>{\n    const program = /** @type {WebGLProgram} */ context.createProgram();\n    context.attachShader(program, shaders.vertex);\n    context.attachShader(program, shaders.fragment);\n    context.linkProgram(program);\n    if (!context.getProgramParameter(program, context.LINK_STATUS)) {\n        console.warn(context.getProgramInfoLog(program));\n        context.deleteProgram(program);\n    }\n    return program;\n};\n/**\n * @param {WebGLRenderingContext} context\n * @param {number} type\n * @param {string} source\n * @param {Object.<string,number>} [view={}]\n * @returns {WebGLShader}\n */ const $b4fab70876281105$var$getShader = (context, type, source, view = {})=>{\n    for(const key in view){\n        const regex = new RegExp(`{{${key}}}`, \"g\");\n        source = source.replaceAll(regex, `${view[key]}`);\n    }\n    const shader = /** @type {WebGLShader} */ context.createShader(type);\n    context.shaderSource(shader, source);\n    context.compileShader(shader);\n    if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {\n        console.warn(context.getShaderInfoLog(shader));\n        context.deleteShader(shader);\n    }\n    return shader;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Methods for decoding dct to dataUrl, and for upsizing decoded images.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n\n\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n/**\n *\n * @param {BlurridDecoder} decoder\n * @returns {string}\n */ const $dad962c3e2511d5c$export$4631f9310db9e583 = (decoder)=>{\n    const { metadata: metadata, coefficients: coefficients } = decoder;\n    const { canvas: canvas, context: context, program: program } = (0, $b4fab70876281105$export$10c7fe55c4ed3d74)(metadata);\n    /** @type {Object.<string,{type:string, data:any}>} */ const uniforms = {\n        \"u_color\": {\n            type: \"uniform4fv\",\n            data: [\n                1,\n                0,\n                0,\n                1\n            ]\n        },\n        \"u_image_width\": {\n            type: \"uniform1f\",\n            data: metadata.image.width\n        },\n        \"u_image_height\": {\n            type: \"uniform1f\",\n            data: metadata.image.height\n        },\n        \"u_lumaDct\": {\n            type: \"uniform1fv\",\n            data: $dad962c3e2511d5c$var$normalizeDctSamples(coefficients.luma, metadata)\n        },\n        \"u_chromaBlueDct\": {\n            type: \"uniform1fv\",\n            data: $dad962c3e2511d5c$var$normalizeDctSamples(coefficients.chromaBlue, metadata)\n        },\n        \"u_chromaRedDct\": {\n            type: \"uniform1fv\",\n            data: $dad962c3e2511d5c$var$normalizeDctSamples(coefficients.chromaRed, metadata)\n        }\n    };\n    for(const key in uniforms){\n        const location = context.getUniformLocation(program, key);\n        // @ts-expect-error - String *can* index WebGLUniformLocation\n        context[uniforms[key].type](location, uniforms[key].data);\n    }\n    const drawData = {\n        primitiveType: context.TRIANGLES,\n        offset: 0,\n        count: 6\n    };\n    const { primitiveType: primitiveType, offset: offset, count: count } = drawData;\n    context.drawArrays(primitiveType, offset, count);\n    return canvas.toDataURL();\n};\n/**\n *\n * @param {number[][]} array2D\n * @param {BlurridMetadata} metadata\n * @returns\n */ const $dad962c3e2511d5c$var$normalizeDctSamples = (array2D, metadata)=>{\n    const length = /** @type {number} */ metadata.sample.max;\n    return Array.from({\n        length: length ** 2\n    }, (_, index)=>{\n        return array2D.flatMap((array1D)=>{\n            return Array.from({\n                length: length\n            }, (_, index)=>array1D[index] || 0);\n        })[index] || 0;\n    });\n};\n/**\n *\n * @param {object} target\n * @param {HTMLCanvasElement} target.canvas\n * @param {CanvasRenderingContext2D} target.context\n * @param {ImageData} imageData\n * @param {BlurridDecoder} decoder\n * @returns {Promise.<string>}\n */ const $dad962c3e2511d5c$export$35004646828cefa0 = (target, imageData, decoder)=>{\n    return new Promise((resolve)=>{\n        const image = document.createElement(\"img\");\n        const listener = ()=>{\n            const { width: width, height: height } = target.canvas;\n            target.context.drawImage(image, 0, 0, width, height);\n            image.removeEventListener(\"load\", listener);\n            image.remove();\n            resolve(target.canvas.toDataURL());\n        };\n        image.addEventListener(\"load\", listener);\n        decoder.metadata.resize(imageData.width);\n        const { canvas: canvas, context: context } = (0, $b4fab70876281105$export$7bfb6a10627b78e8)(decoder.metadata);\n        context.putImageData(imageData, 0, 0);\n        image.src = canvas.toDataURL();\n    });\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Wrapper around worker to allow for instantiating workers on the fly.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n *\n * @returns {Worker}\n */ const $11e58dde46b2e744$export$a34c9cac3423e245 = ()=>{\n    return new Worker(new URL(\"worker.e95a93f7.js\", import.meta.url));\n};\n\n\n\n\n// @@body\nclass $1b148c2943747f56$export$e4065b753f58196c extends HTMLImageElement {\n    decoder = new (0, $7285f96793324acb$export$a17c6f6fb2637705)(this.dataset.blurrid || \"A\".repeat(10));\n    constructor(){\n        super();\n        const listener = ()=>{\n            this.removeEventListener(\"load\", listener);\n            this.blur();\n            this.dataset.loading === \"onclick\" ? this.loadOnClick() : this.dataset.loading === \"lazy\" ? this.loadOnIntersection() : this.loadImage();\n        };\n        this.addEventListener(\"load\", listener);\n        if (this.#blurWidth) this.decoder.metadata.resize(this.#blurWidth);\n        const { canvas: canvas } = (0, $b4fab70876281105$export$7bfb6a10627b78e8)(this.decoder.metadata);\n        this.src = canvas.toDataURL();\n    }\n    blur() {\n        const maxSamples = this.decoder.metadata.sample.max;\n        if (!window.WebGLRenderingContext || maxSamples > 16) this.dataset.loading = \"eager\";\n        else this.src = (0, $dad962c3e2511d5c$export$4631f9310db9e583)(this.decoder);\n    }\n    loadImage() {\n        const image = document.createElement(\"img\");\n        for (const attribute of this.attributes){\n            const { name: name, value: value } = attribute;\n            if (this.#reservedAttributes.includes(name)) continue;\n            image.setAttribute(name, value);\n        }\n        const listener = ()=>{\n            image.removeEventListener(\"load\", listener);\n            // Hard set image (and by extension also cloned image) width and\n            // height to avoid content jumping due to `position: absolute`\n            // setting size relative to page root element if the immediate\n            // image parent container does not have `position:relative` set\n            // (see here https://stackoverflow.com/a/14327156). Also avoids\n            // content jumping if the decoded blur size and image src size are\n            // different (for instance if the blur is calculated on the full\n            // image, and the fetched src is a downsized image).\n            const { width: width, height: height } = this.getBoundingClientRect();\n            image.style.width = `${width}px`;\n            image.style.height = `${height}px`;\n            const keyframes = [\n                {\n                    opacity: 1\n                },\n                {\n                    opacity: 0\n                }\n            ];\n            const options = {\n                easing: \"ease-out\",\n                duration: 500\n            };\n            const clone = /** @type {HTMLImageElement} */ image.cloneNode();\n            clone.style.opacity = \"0\";\n            clone.style.position = \"absolute\";\n            this.before(clone);\n            this.animate(keyframes, options);\n            clone.animate(keyframes, {\n                ...options,\n                direction: \"reverse\"\n            }).addEventListener(\"finish\", ()=>{\n                this.replaceWith(image);\n                clone.remove();\n            });\n        };\n        image.addEventListener(\"load\", listener);\n        if (this.dataset.srcset) image.setAttribute(\"srcset\", this.dataset.srcset);\n        image.setAttribute(\"src\", this.dataset.src || \"\");\n    }\n    loadOnClick() {\n        const listener = ()=>{\n            this.removeEventListener(\"click\", listener);\n            this.loadImage();\n        };\n        this.addEventListener(\"click\", listener);\n    }\n    loadOnIntersection() {\n        const options = /** @type {IntersectionObserverInit} */ {\n            threshold: 0.5\n        };\n        const observer = new IntersectionObserver((entries)=>{\n            const entry = entries[0];\n            if (entry.isIntersecting) {\n                observer.disconnect();\n                this.loadImage();\n            }\n        }, options);\n        observer.observe(this);\n    }\n    get #blurWidth() {\n        if (this.dataset.size) return parseInt(this.dataset.size);\n        if (!this.sizes || !this.dataset.srcset) return undefined;\n        let slotSize;\n        const regexps = {\n            sizes: /(?<query>\\(.*\\))[\\s\\n]*(?<width>\\d*)(?<unit>px|vw),/g,\n            sizesFallback: /(?<width>\\d*)(?<unit>px|vw)[\\s\\n]*$/,\n            srcset: /[\\s\\n](?<srcsetWidth>\\d*)w,?/g\n        };\n        //\n        for (const match of this.sizes.matchAll(regexps.sizes)){\n            const { query: query, width: width, unit: unit } = match?.groups || {};\n            if (matchMedia(query).matches) {\n                slotSize = {\n                    width: width,\n                    unit: unit\n                };\n                break;\n            }\n        }\n        //\n        if (!slotSize) {\n            const { width: width, unit: unit } = this.sizes.match(regexps.sizesFallback)?.groups || {};\n            slotSize = {\n                width: width,\n                unit: unit\n            };\n        }\n        //\n        const slotWidth = slotSize?.unit === \"vw\" ? parseInt(slotSize?.width || \"0\") / 100 * window.innerWidth : parseInt(slotSize?.width || \"0\");\n        //\n        for (const match of this.dataset.srcset.matchAll(regexps.srcset)){\n            const { srcsetWidth: srcsetWidth } = match?.groups || {};\n            if (parseInt(srcsetWidth) >= slotWidth) return parseInt(srcsetWidth);\n        }\n        return undefined;\n    }\n    get #reservedAttributes() {\n        return [\n            \"is\",\n            \"src\",\n            \"data-src\",\n            \"data-srcset\",\n            \"data-loading\",\n            \"data-blurrid\",\n            \"data-worker-start\",\n            \"data-worker-steps\"\n        ];\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file BlurridImage web component, including worker fallback.\n * @author James Reid\n */ // @ts-check\n// @@imports-package\n\n\n\n// @@body\nlet /** @type {WorkerManager|undefined} */ $6214776a3babbdfa$var$blurridWorkerManager;\nclass $6214776a3babbdfa$export$a549820b6a231fbc extends (0, $1b148c2943747f56$export$e4065b753f58196c) {\n    #workerStart = parseInt(this.dataset.workerStart || \"16\");\n    #workerSteps = parseInt(this.dataset.workerSteps || \"2\");\n    constructor(){\n        super();\n    }\n    blur() {\n        const maxSamples = this.decoder.metadata.sample.max;\n        if (!window.WebGLRenderingContext || maxSamples > 16) {\n            if (!$6214776a3babbdfa$var$blurridWorkerManager) $6214776a3babbdfa$var$blurridWorkerManager = new (0, $86e52ea92617c364$export$bcff6015853c67ce)((0, $11e58dde46b2e744$export$a34c9cac3423e245));\n            const target = (0, $b4fab70876281105$export$7bfb6a10627b78e8)(this.decoder.metadata);\n            this.stepWorker(target.canvas.toDataURL(), target);\n        } else this.src = (0, $dad962c3e2511d5c$export$4631f9310db9e583)(this.decoder);\n    }\n    /**\n   *\n   * @param {string} dataUrl\n   * @param {object} target\n   * @param {HTMLCanvasElement} target.canvas\n   * @param {CanvasRenderingContext2D} target.context\n   * @param {number} [width]\n   */ stepWorker(dataUrl, target, width) {\n        this.src = dataUrl;\n        width ??= this.#workerStart;\n        if (width < this.#workerStart * 2 ** this.#workerSteps) {\n            const message = {\n                serializedDct: this.decoder.serializedDct,\n                width: width * 2\n            };\n            $6214776a3babbdfa$var$blurridWorkerManager?.enqueue(message, (event)=>{\n                const { imageData: imageData, imageData: { width: width } } = event.data;\n                (0, $dad962c3e2511d5c$export$35004646828cefa0)(target, imageData, this.decoder).then((dataUrl)=>{\n                    this.stepWorker(dataUrl, target, width);\n                });\n            });\n        }\n    }\n}\n\n\n\n\n\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Import required lucide icons.\n * @author James Reid\n */ // @ts-check\n// @@imports-dependencies\n\n// @@body\n(0, $cw5NC$createIcons)({\n    icons: {\n        Info: $cw5NC$Info\n    }\n}); // @@no-exports\n\n\n// @@body\ncustomElements.define(\"blurrid-image\", (0, $6214776a3babbdfa$export$a549820b6a231fbc), {\n    extends: \"img\"\n}); // @@no-exports\n\n\n//# sourceMappingURL=index.6581faf8.js.map\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Demo site entrypoint.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-dependencies\nimport { BlurridImageWorker } from \"../../package/web.js\"\n\n// @@imports-module\nimport \"./icons.js\"\n\n// @@body\ncustomElements.define(\"blurrid-image\", BlurridImageWorker, { extends: \"img\" })\n\n// @@no-exports\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Web image component and utility entrypoint.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@no-body\n\n// @@exports\nexport { BlurridImage, BlurridImageWorker } from \"./components/index.js\"\nexport { getDataUrl } from \"./shader/index.js\"\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Export custom blurrid web components.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@no-body\n\n// @@exports\nexport * from \"./BlurridImage.js\"\nexport * from \"./BlurridImageWorker.js\"\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file BlurridImage web component, not including worker fallback.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-package\nimport { BlurridDecoder } from \"../dct/index.js\"\nimport { getDataUrl, getCanvas2D } from \"../shader/index.js\"\n\n// @@body\nclass BlurridImage extends HTMLImageElement {\n    decoder = new BlurridDecoder(this.dataset.blurrid || \"A\".repeat(10))\n\n    constructor() {\n        super()\n\n        const listener = () => {\n            this.removeEventListener(\"load\", listener)\n            this.blur()\n            this.dataset.loading === \"onclick\" ? this.loadOnClick()\n                : this.dataset.loading === \"lazy\" ? this.loadOnIntersection()\n                : this.loadImage()\n        }\n        this.addEventListener(\"load\", listener)\n\n        if (this.#blurWidth) { this.decoder.metadata.resize(this.#blurWidth) }\n\n        const { canvas } = getCanvas2D(this.decoder.metadata)\n        this.src = canvas.toDataURL()\n    }\n\n    blur() {\n        const maxSamples = this.decoder.metadata.sample.max\n        if (!window.WebGLRenderingContext || maxSamples > 16) {\n            this.dataset.loading = \"eager\"\n        }\n        else { this.src = getDataUrl(this.decoder) }\n    }\n\n    loadImage() {\n        const image = document.createElement(\"img\")\n\n        for (const attribute of this.attributes) {\n            const { name, value } = attribute\n            if (this.#reservedAttributes.includes(name)) { continue }\n            image.setAttribute(name, value)\n        }\n\n        const listener = () => {\n            image.removeEventListener(\"load\", listener)\n\n            // Hard set image (and by extension also cloned image) width and\n            // height to avoid content jumping due to `position: absolute`\n            // setting size relative to page root element if the immediate\n            // image parent container does not have `position:relative` set\n            // (see here https://stackoverflow.com/a/14327156). Also avoids\n            // content jumping if the decoded blur size and image src size are\n            // different (for instance if the blur is calculated on the full\n            // image, and the fetched src is a downsized image).\n            const { width, height } = this.getBoundingClientRect()\n            image.style.width = `${width}px`\n            image.style.height = `${height}px`\n\n            const keyframes = [{ opacity: 1 }, { opacity: 0 }]\n            const options = { easing: \"ease-out\", duration: 500 }\n\n            const clone = /** @type {HTMLImageElement} */ (image.cloneNode())\n            clone.style.opacity = \"0\"\n            clone.style.position = \"absolute\"\n            this.before(clone)\n\n            this.animate(keyframes, options)\n            clone.animate(keyframes, { ...options, direction: \"reverse\" })\n                .addEventListener(\"finish\", () => {\n                    this.replaceWith(image)\n                    clone.remove()\n                })\n        }\n\n        image.addEventListener(\"load\", listener)\n\n        if (this.dataset.srcset) {\n            image.setAttribute(\"srcset\", this.dataset.srcset)\n        }\n        image.setAttribute(\"src\", this.dataset.src || \"\")\n    }\n\n    loadOnClick() {\n        const listener = () => {\n            this.removeEventListener(\"click\", listener)\n            this.loadImage()\n        }\n\n        this.addEventListener(\"click\", listener)\n    }\n\n    loadOnIntersection() {\n        const options = /** @type {IntersectionObserverInit} */ ({\n            threshold: 0.5\n        })\n\n        const observer = new IntersectionObserver(entries => {\n            const entry = entries[0]\n            if (entry.isIntersecting) {\n                observer.disconnect()\n                this.loadImage()\n            }\n        }, options)\n\n        observer.observe(this)\n    }\n\n    get #blurWidth() {\n        if (this.dataset.size) { return parseInt(this.dataset.size) }\n        if (!this.sizes || !this.dataset.srcset) { return undefined }\n\n        let slotSize\n        const regexps = {\n            sizes: /(?<query>\\(.*\\))[\\s\\n]*(?<width>\\d*)(?<unit>px|vw),/g,\n            sizesFallback: /(?<width>\\d*)(?<unit>px|vw)[\\s\\n]*$/,\n            srcset: /[\\s\\n](?<srcsetWidth>\\d*)w,?/g\n        }\n\n        //\n        for (const match of this.sizes.matchAll(regexps.sizes)) {\n            const { query, width, unit } = match?.groups || {}\n            if (matchMedia(query).matches) {\n                slotSize = { width, unit }\n                break\n            }\n        }\n\n        //\n        if (!slotSize) {\n            const { width, unit } =\n                this.sizes.match(regexps.sizesFallback)?.groups || {}\n            slotSize = { width, unit }\n        }\n\n        //\n        const slotWidth = slotSize?.unit === \"vw\"\n            ? (parseInt(slotSize?.width || \"0\")) / 100 * window.innerWidth\n            : parseInt(slotSize?.width || \"0\")\n\n        //\n        for (const match of this.dataset.srcset.matchAll(regexps.srcset)) {\n            const { srcsetWidth } = match?.groups || {}\n            if (parseInt(srcsetWidth) >= slotWidth) {\n                return parseInt(srcsetWidth)\n            }\n        }\n\n        return undefined\n    }\n\n    get #reservedAttributes() {\n        return [\n            \"is\",\n            \"src\",\n            \"data-src\",\n            \"data-srcset\",\n            \"data-loading\",\n            \"data-blurrid\",\n            \"data-worker-start\",\n            \"data-worker-steps\"\n        ]\n    }\n}\n\n// @@exports\nexport { BlurridImage }\n","// Copyright (c) 2023 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Export dct compression methods.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@no-body\n\n// @@exports\nexport * from \"./array-conversions.js\"\nexport * from \"./BlurridDecoder.js\"\nexport * from \"./BlurridEncoder.js\"\nexport * from \"./BlurridMetadata.js\"\nexport * from \"./builders.js\"\nexport * from \"./colorspace-conversions.js\"\nexport * from \"./consumers.js\"\nexport * from \"./decode.js\"\nexport * from \"./encode.js\"\nexport * from \"./serialize.js\"\nexport * from \"./SubsampleSelector.js\"\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Array dimension conversions for jpg dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-utils\nimport { DecoratedError } from \"../utils/decorate-cli.js\"\n\n// @@body\n/**\n *\n * @param {number[]} sampleData\n * @param {number} width\n * @param {number} channels\n * @returns {number[][][]}\n */\nconst expandSample = (sampleData, width, channels = 3) => {\n    if (sampleData.length % channels) {\n        throw new DecoratedError({\n            name: \"ChannelError\",\n            message: \"Data length is not a multiple of requested channel count\",\n            \"data-length\": sampleData.length,\n            \"channels-requested\": channels\n        })\n    }\n\n    /** @type {number[][]} */\n    const channelData = Array.from(Array.from({ length: channels }), () => [])\n    for (const [i, pixel] of sampleData.entries()) {\n        channelData[i % channels].push(pixel)\n    }\n\n    return channelData.map(channel => expandChannel(channel, width))\n}\n\n/**\n *\n * @param {number[]} channel1D\n * @param {number} width\n * @returns {number[][]}\n */\nconst expandChannel = (channel1D, width) => {\n    if (channel1D.length % width) {\n        throw new DecoratedError({\n            name: \"ChannelError\",\n            message: \"Channel length is not a multiple of row width\",\n            \"channel-length\": channel1D.length,\n            \"row-width\": width\n        })\n    }\n\n    /** @type {number[][]} */\n    const channel2D = Array.from(\n        Array.from({ length: channel1D.length / width }),\n        () => []\n    )\n\n    for (const [i, pixel] of channel1D.entries()) {\n        channel2D[Math.floor(i / width)].push(pixel)\n    }\n\n    return channel2D\n}\n\n/**\n *\n * @param {number[][][]} expandedSample\n * @returns {number[]}\n */\nconst collapseSample = expandedSample => {\n    const channelData = expandedSample.map(channel => collapseChannel(channel))\n\n    const length = channelData[0].length\n    const sampleData = Array\n        .from({ length: channelData.length * length })\n        .fill(0)\n\n    for (const [i, channel] of channelData.entries()) {\n        if (channel.length !== length) {\n            throw new DecoratedError({\n                name: \"ChannelError\",\n                message: \"Sample channels not of same length\",\n                \"default-length\": length,\n                \"channel-length\": channel.length\n            })\n        }\n        for (const [j, pixel] of channel.entries()) {\n            sampleData[channelData.length * j + i] = pixel\n        }\n    }\n\n    return sampleData\n}\n\n/**\n *\n * @param {number[][]} channel2D\n * @returns {number[]}\n */\nconst collapseChannel = channel2D => {\n    const width = channel2D[0].length\n    const channel1D = []\n\n    for (const channelRow of channel2D) {\n        if (channelRow.length !== width) {\n            throw new DecoratedError({\n                name: \"ChannelError\",\n                message: \"Channel row width does not match sample width\",\n                \"sample-width\": length,\n                \"row-width\": channelRow.length\n            })\n        }\n        channel1D.push(...channelRow)\n    }\n\n    return channel1D\n}\n\n// @@exports\nexport { expandSample, collapseSample }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Functions for decorating cli strings.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n * Custom error which renders an error in a uniform way, taking an options\n * object with reserved name and message fields, and then any other fields\n * relevant to the error, and rendering them with indentation.\n */\nclass DecoratedError extends Error {\n    /**\n     * Build new error based on supplied options object which may set the custom\n     * name of the error, the top level message of the error, and then any\n     * number of other custom fields.\n     *\n     * @param {Object.<string,string|number|boolean>} options - Options object\n     *      containing any string keys, and string, number or boolean values.\n     */\n    constructor(options) {\n        super()\n        let message = \"\"\n\n        // Parse all properties in options argument; if key is name, use value\n        // to set the custom name of the error, if key is message, append value\n        // top of error message, otherwise render a grey, tabbed key-value\n        // pair to the end of the message string.\n        for (const key in options) {\n            switch (key) {\n                case \"name\":\n                    this.name = /** @type {string} */ (options[key])\n                    break\n                case \"message\":\n                    message = `${options[key]}\\n${message}`\n                    break\n                default: {\n                    const detail = `${key}: ${options[key]}`\n                    message = `${message}${decorateFg(detail, \"gray\", 1)}\\n`\n                }\n            }\n        }\n\n        // Set error message which will be displayed.\n        this.message = message || \"\"\n    }\n}\n\n/**\n * Decorate a string with control characters for changing cli string colors and\n * text decoration. Adds supplied list of modifiers for the string, then uses\n * reset character to set text back to default.\n *\n * @summary Return original string decorated with control characters.\n * @param {string} string - String to be decorated.\n * @param {object} options - Options object.\n * @param {string[]=} options.modifiers - String array of modifiers/control\n *      characters to apply input string.\n * @param {number=} options.tabs - Number of tab indents to include on string.\n * @param {number=} options.tabSize - Number of spaces for each tab.\n * @returns {string} Original string decorated with control characters.\n */\nconst decorate = (string, { modifiers = [], tabs = 0, tabSize = 4 } = {}) => {\n    // Make compound modifier string form array of supplied control characters.\n    let compoundModifier = \"\"\n    for (const modifier of modifiers) {\n        compoundModifier = `${compoundModifier}${modifier}`\n    }\n\n    // Wrap input string with control characters and reset character.\n    const reset = cliModifiers.decorations.reset\n    const indent = \" \".repeat(tabs * tabSize)\n    return `${compoundModifier}${indent}${string}${reset}`\n}\n\n/**\n * Wrapper around decorate function to decorate a string with a foreground\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a foreground colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired foreground colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */\nconst decorateFg = (string, color, tabs = 0) => {\n    const colorModifier = cliModifiers.fgColors[color]\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier\n        ? decorate(string, { modifiers: [colorModifier], tabs })\n        : decorate(string, { tabs })\n}\n\n/**\n * Wrapper around decorate function to decorate a string with a background\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a background colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired background colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */\nconst decorateBg = (string, color, tabs = 0) => {\n    const colorModifier = cliModifiers.bgColors[color]\n\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier\n        ? decorate(string, { modifiers: [colorModifier], tabs })\n        : decorate(string, { tabs })\n}\n\n/**\n * Wrapper around String.prototype.padEnd method, which pads end of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad end of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padEnd method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */\nconst padEndDecorated = (string, maxLength, fillString) => {\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0\n    return string.padEnd(maxLength + decoratorLength, fillString)\n}\n\n/**\n * Wrapper around String.prototype.padStart method, which pads start of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad start of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padStart method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */\nconst padStartDecorated = (string, maxLength, fillString) => {\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0\n    return string.padStart(maxLength + decoratorLength, fillString)\n}\n\n// Object of cli control strings for decorations etc.\nconst cliModifiers = {\n    // Foreground modifiers.\n    /** @type {Object.<string,string>} */\n    fgColors: {\n        black: \"\\x1b[30m\",\n        red: \"\\x1b[31m\",\n        green: \"\\x1b[32m\",\n        yellow: \"\\x1b[33m\",\n        blue: \"\\x1b[34m\",\n        magenta: \"\\x1b[35m\",\n        cyan: \"\\x1b[36m\",\n        white: \"\\x1b[37m\",\n        gray: \"\\x1b[90m\"\n    },\n\n    // Background modifiers.\n    /** @type {Object.<string,string>} */\n    bgColors: {\n        black: \"\\x1b[40m\",\n        red: \"\\x1b[41m\",\n        green: \"\\x1b[42m\",\n        yellow: \"\\x1b[43m\",\n        blue: \"\\x1b[44m\",\n        magenta: \"\\x1b[45m\",\n        cyan: \"\\x1b[46m\",\n        white: \"\\x1b[47m\",\n        gray: \"\\x1b[100m\"\n    },\n\n    // Decoration modifiers.\n    /** @type {Object.<string,string>} */\n    decorations: {\n        reset: \"\\x1b[0m\",\n        bright: \"\\x1b[1m\",\n        dim: \"\\x1b[2m\",\n        underline: \"\\x1b[4m\",\n        blink: \"\\x1b[5m\",\n        reverse: \"\\x1b[7m\",\n        hidden: \"\\x1b[8m\"\n    }\n}\n\n/**\n * Convert kebab-case string to camelCase string, removing all hyphens in input\n * string, and capitalising the first character following each hyphen. Options\n * available for generating UpperCamelCase strings, and spaced strings too.\n *\n * @summary Convert kebab-case string to camelCase string.\n * @param {string} kebabCaseString - Input kebab-case string.\n * @param {boolean} isUpper - Should return string be in UpperCamelCase?\n * @param {boolean} isSpaced - Should return string replace hyphens with\n *      whitespace characters?\n * @returns {string} camelCase string version of input.\n */\nconst toCamelCase = (kebabCaseString, isUpper = false, isSpaced = false) => {\n    // Reduce split input string with starting value object containing an empty\n    // string and flag set to isUpper for if next character should be capital.\n    return (kebabCaseString.split(\"\").reduce((acc, cur) => {\n        // Ignore hyphens, or replace with spaces as required.\n        if (cur === \"-\") {\n            return isSpaced\n                ? { string: `${acc.string} `, isCapital: true }\n                : { ...acc, isCapital: true }\n        }\n\n        // Concatenate string with next character set to uppercase if required.\n        const nextChar = acc.isCapital ? cur.toUpperCase() : cur.toLowerCase()\n        return { string: `${acc.string}${nextChar}`, isCapital: false }\n    }, { string: \"\", isCapital: isUpper }).string)\n}\n\n/**\n * Convert camelCaseString to kebab-case-string, adding hyphens between words.\n * If input string includes spaces (for example the verbatim title of a\n * markdown documentation file), replace with hyphens - this is good for\n * converting a title string to a valid kebab-case-filename. Option also\n * available for generating Upper-Kebab-Case strings.\n *\n * @summary Convert camelCaseString to kebab-case-string.\n * @param {string} camelCaseString - Input camelCaseString.\n * @param {boolean} isUpper - Should return string be in Upper-Kebab-Case?\n * @returns {string} kebab-case-string version of input.\n */\nconst toKebabCase = (camelCaseString, isUpper = false) => {\n    // Reduce split input string with starting value object containing an empty\n    // string and a new word flag set to true.\n    return (camelCaseString.split(\"\").reduce((acc, cur) => {\n        // Ignore spaces in the input string, but set new word flag to true.\n        if (cur === \" \") {\n            return { ...acc, isNewWord: true }\n        }\n\n        // If new word flag is set, or if an uppercase letter is found, insert\n        // a hyphen before appending the upper/lowercase version of the current\n        // letter depending on the isUpper argument.\n        else if (acc.isNewWord || cur.match(/[A-Z]/)) {\n            const nextChar = isUpper ? cur.toUpperCase() : cur.toLowerCase()\n            return acc.string\n                ? { string: `${acc.string}-${nextChar}`, isNewWord: false }\n                : { string: `${nextChar}`, isNewWord: false }\n        }\n\n        // Otherwise, append current letter in lowercase.\n        const nextChar = cur.toLowerCase()\n        return { string: `${acc.string}${nextChar}`, isNewWord: false }\n    }, { string: \"\", isNewWord: true }).string)\n}\n\n// @@exports\nexport {\n    DecoratedError,\n    decorate,\n    decorateFg,\n    decorateBg,\n    padEndDecorated,\n    padStartDecorated,\n    cliModifiers,\n    toCamelCase,\n    toKebabCase\n}\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Wrapper class around blurrid dct decoding functions.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\nimport { collapseSample } from \"./array-conversions.js\"\nimport { BlurridMetadata } from \"./BlurridMetadata.js\"\nimport { buildDctArray3D } from \"./builders.js\"\nimport { yCbCrArrayToRgbaArray } from \"./colorspace-conversions.js\"\nimport { decodePixelArray3D } from \"./decode.js\"\nimport { BUFFER_LOCATIONS } from \"./serialize.js\"\nimport { SubsampleSelector } from \"./SubsampleSelector.js\"\n\n// @@imports-utils\nimport { BitBuffer, DecoratedError } from \"../utils/index.js\"\n\n// @@body\nclass BlurridDecoder {\n    #serializedDct\n    #buffer\n    #metadata\n    #coefficients\n\n    /**\n     *\n     * @param {string} serializedDct\n     */\n    constructor(serializedDct) {\n        // absolute minimum 10\n        if (!serializedDct.match(/^[A-Za-z0-9\\-_]{16,}$/)) {\n            throw new DecoratedError({\n                name: \"BlurridDecoderError\",\n                message: \"String minimum 16 url-safe base 64 encoded chars\",\n                \"serialized-dct\": serializedDct\n            })\n        }\n\n        this.#serializedDct = serializedDct\n        this.#buffer = BitBuffer.from(serializedDct)\n        this.#metadata = new BlurridMetadata(this.#deserializeMetadata())\n        this.#coefficients = this.#deserializeCoefficients()\n    }\n\n    toImageData() {\n        const { luma, chromaBlue, chromaRed } = this.#coefficients\n        const array3D = [luma, chromaBlue, chromaRed]\n\n        return yCbCrArrayToRgbaArray(\n            collapseSample(decodePixelArray3D(array3D, this.#metadata))\n        )\n    }\n\n    #deserializeMetadata() {\n        //\n        this.#buffer.readPointer = BUFFER_LOCATIONS.METADATA\n        //\n        const image = {\n            width: this.#buffer.read(16),\n            height: this.#buffer.read(16)\n        }\n        const sample = {\n            width: this.#buffer.read(8),\n            height: this.#buffer.read(8)\n        }\n\n        return { image, sample }\n    }\n\n    #deserializeSubsampling() {\n        //\n        this.#buffer.readPointer = BUFFER_LOCATIONS.SUBSAMPLING\n\n        const luma = this.#buffer.read(3)\n        const chromaBlue = this.#buffer.read(3)\n        const chromaRed = this.#buffer.read(3)\n\n        return new SubsampleSelector(`${luma}:${chromaBlue}:${chromaRed}`)\n    }\n\n    #deserializeCoefficients() {\n        const dctBuilder = this.#dctBuilder()\n        let [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */\n            (dctBuilder.next().value)\n\n        //\n        this.#buffer.readPointer = BUFFER_LOCATIONS.COEFFICIENTS\n        this.#buffer.lastReadSize = BUFFER_LOCATIONS.ASSUMED_COEFFICIENT_SIZE\n\n        /* eslint-disable-next-line no-constant-condition -- break from in while\n        loop ends loop. */\n        while (true) {\n            const coefficient = this.#buffer.readRelative({ signed: true })\n            if (isNaN(coefficient)) { break }\n\n            // check if done, and break\n            [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */\n                (dctBuilder.next(coefficient).value)\n        }\n\n        return { luma, chromaBlue, chromaRed }\n    }\n\n    #dctBuilder() {\n        //\n        return buildDctArray3D(\n            this.#metadata.sample.width,\n            this.#metadata.sample.height,\n            this.#deserializeSubsampling()\n        )\n    }\n\n    get serializedDct() { return this.#serializedDct }\n\n    get metadata() { return this.#metadata }\n\n    get coefficients() { return this.#coefficients }\n}\n\n// @@exports\nexport { BlurridDecoder }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Class for building and accessing dct metadata.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\nclass BlurridMetadata {\n    #image\n    #sample\n\n    /**\n     *\n     * @param {object} obj\n     * @param {object} obj.image\n     * @param {number} obj.image.width\n     * @param {number} obj.image.height\n     * @param {object} obj.sample\n     * @param {number} obj.sample.width\n     * @param {number} obj.sample.height\n     */\n    constructor({ image, sample }) {\n        this.#image = image\n        this.#sample = { ...sample, max: Math.max(sample.width, sample.height) }\n    }\n\n    /**\n     *\n     * @param {number} width\n     */\n    resize(width) {\n        this.#image.height = Math\n            .round(this.#image.height * width / this.#image.width)\n        this.#image.width = width\n    }\n\n    get image() { return this.#image }\n\n    get sample() { return this.#sample }\n}\n\n// @@exports\nexport { BlurridMetadata }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Generators for building arrays of dct coefficients.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { SubsampleSelector } from \"./SubsampleSelector.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n// build dct coefficients\n/**\n *\n * @param {number} width\n * @param {number} height\n * @param {SubsampleSelector} subsampleSelector\n */\nfunction* buildDctArray3D(width, height, subsampleSelector) {\n    const builders = {\n        luma: buildDctArray2D(width, height),\n        chromaBlue: buildDctArray2D(width, height),\n        chromaRed: buildDctArray2D(width, height)\n    }\n    const array3D = [\n        builders.luma.next().value,\n        builders.chromaBlue.next().value,\n        builders.chromaRed.next().value,\n    ]\n\n    let index = 0\n    do {\n        const value = /** @type {number} */ (yield array3D)\n        const key = subsampleSelector.key(index)\n\n        const iteration = builders[key].next(value)\n        if (iteration.done) { break }\n        key === \"luma\" ? array3D[0] = iteration.value\n            : key === \"chromaBlue\" ? array3D[1] = iteration.value\n            : array3D[2] = iteration.value\n    } while (++index)\n}\n\n// build 2d array from diagonal\n/**\n *\n * @param {number} width\n * @param {number} height\n */\nfunction* buildDctArray2D(width, height) {\n    // /** @type {number[][]} */\n    // const array2D = Array.from(\n    //     Array.from({ length: height }),\n    //     () => Array.from({ length: width }).fill(0)\n    // )\n    const array2D = Array.from(\n        Array.from({ length: width }),\n        () => Array.from({ length: height }).fill(0)\n    )\n    let [x, y] = [0, 0]\n\n    while (true) {\n        // array2D[y][x] = /** @type {number} */ (yield array2D)\n        array2D[x][y] = /** @type {number} */ (yield array2D)\n\n        if (y === 0 || x === width - 1) {\n            const sum = x + y + 1\n            if (sum > width + height - 1) { break }\n            y = x >= height - 1 ? height - 1 : x + 1\n            x = sum - y\n        }\n        else { y--; x++ }\n    }\n}\n\n// @@exports\nexport { buildDctArray3D }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Class for processing subsample strings.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-utils\nimport { DecoratedError } from \"../utils/index.js\"\n\n// @@body\nclass SubsampleSelector {\n    #luma\n    #chromaBlue\n    #chromaRed\n    #total\n\n    /**\n     *\n     * @param {string} subsampling\n     */\n    constructor(subsampling) {\n        //\n        const { luma, chromaBlue, chromaRed } = subsampling\n            .match(/^(?<luma>[0-7]):(?<chromaBlue>[0-7]):(?<chromaRed>[0-7])$/)\n            ?.groups || {}\n\n        //\n        if (!luma || !chromaBlue || !chromaRed) {\n            throw new DecoratedError({\n                name: \"SubsamplingError\",\n                message: \"Must be of form \\\"x:y:z\\\", digits from 0-7 inclusive\",\n                \"subsampling-string\": subsampling\n            })\n        }\n\n        //\n        this.#luma = parseInt(luma)\n        this.#chromaBlue = parseInt(chromaBlue)\n        this.#chromaRed = parseInt(chromaRed)\n        this.#total = this.#luma + this.#chromaBlue + this.#chromaRed\n    }\n\n    /**\n     *\n     * @param {number} index\n     * @returns {\"luma\"|\"chromaBlue\"|\"chromaRed\"}\n     */\n    key(index) {\n        //\n        const subsample = index % this.#total\n\n        //\n        return subsample < this.#luma ? \"luma\"\n            : subsample < this.#luma + this.#chromaBlue ? \"chromaBlue\"\n            : \"chromaRed\"\n    }\n\n    get luma() { return this.#luma }\n\n    get chromaBlue() { return this.#chromaBlue }\n\n    get chromaRed() { return this.#chromaRed }\n}\n\n// @@exports\nexport { SubsampleSelector }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Export utility methods.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@no-body\n\n// @@exports\nexport * from \"./BitBuffer.js\"\nexport * from \"./decorate-cli.js\"\nexport * from \"./WorkerManager.js\"\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Buffer class allowing control at bit level rather than byte level.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\nimport { DecoratedError } from \"./decorate-cli.js\"\n\n// @@body\n/**\n * Buffer class allowing control over an appropriately sized array buffer at the\n * bit level rather than at the byte level.\n */\nclass BitBuffer {\n    #buffer\n    #readPointer\n    #lastReadSize\n    #writePointer\n    #lastWriteSize\n\n    /**\n     * Configure internal buffer property and required pointers.\n     *\n     * @param {object} obj - Configuration object argument.\n     * @param {number} [obj.length] - Maximum character length of buffer when\n     *      converted to url-safe base64 string.\n     * @param {number} [obj.size] - Size of BitBuffer in *bytes*. Defaults to\n     *      maximum allowable size as specified by the character length value.\n     * @param {ArrayBuffer} [obj.buffer] - Internal array buffer.\n     */\n    constructor({\n        length = 16,\n        size = Math.floor(length * 6 / 8),\n        buffer = new ArrayBuffer(size)\n    } = {}) {\n        // Assign internal array buffer for implementation of BitBuffer.\n        this.#buffer = buffer\n\n        // Assign internal read pointers.\n        this.#readPointer = 0\n        this.#lastReadSize = 0\n\n        // Assign internal write pointers.\n        this.#writePointer = 0\n        this.#lastWriteSize = 0\n    }\n\n    /**\n     * Write an integer directly to internal buffer, updating write pointers to\n     * the end of the written data.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.size] - Size of buffer segment to write in bits.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    write(int, {\n        size = BitBuffer.#bitLength(int),\n        offset = this.#writePointer,\n        signed = false\n    } = {}) {\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable()\n            .append(int, { size, offset, signed })\n        if (!writeable.isWriteable) { return NaN }\n\n        return this.#write(int, { size, offset, signed })\n    }\n\n    /**\n     * Write an integer to internal buffer with an absolute size declaration to\n     * indicate how many bits are written (i.e. 5 additional bits written\n     * indicating length of written data between 0 and 32 bits). Update write\n     * pointers to the end of the written data.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    writeAbsolute(int, { offset = this.#writePointer, signed = false } = {}) {\n        // Size declaration data with the size of buffer segment it will occupy.\n        const resize = { value: BitBuffer.#bitLength(int), size: 5 }\n\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable()\n            .append(resize.value, { ...resize, offset })\n            .append(int, { signed })\n        if (!writeable.isWriteable) { return NaN }\n\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, { ...resize, offset })\n        const uint32 = this.#write(int, { signed })\n\n        return uint32\n    }\n\n    /**\n     * Write an integer to internal buffer with a relative size declaration to\n     * indicate how many bits are written (i.e. 1 \"sign\" bit to indicate if more\n     * or less bits than the previous write call are being written, and n \"0\"\n     * bits where n is the relative size between the previous and next write\n     * call sizes). Update write pointers to the end of the written data.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    writeRelative(int, { offset = this.#writePointer, signed = false } = {}) {\n        // Write relative method relies on the first bit of the written integer\n        // being \"1\", and therefore cannot write integer \"0\".\n        if (int === 0) { int = 1 }\n\n        // Size declaration data with the size of buffer segment it will occupy.\n        const relativeSize = BitBuffer.#bitLength(int) - this.#lastWriteSize\n        const resize = {\n            // If increasing size, write a 1 bit shifted by the amount of bits\n            // the data is bigger by, otherwise write a 0. Preserve required\n            // bit length of size declaration using size property.\n            value: relativeSize > 0 ? (1 << relativeSize) >>> 0 : 0,\n            size: Math.abs(relativeSize) + 1\n        }\n\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable()\n            .append(resize.value, { ...resize, offset })\n            .append(int, { signed })\n        if (!writeable.isWriteable) { return NaN }\n\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, { ...resize, offset })\n        const uint32 = this.#write(int, { signed })\n\n        return uint32\n    }\n\n    /**\n     * Write a string of arbitrary length to the internal buffer.\n     *\n     * @param {string} string - String to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @returns {string} String written to buffer.\n     */\n    writeString(string, { offset = this.#writePointer } = {}) {\n        // Size declaration data for bit length of length of string declaration.\n        const resize = {\n            value: BitBuffer.#bitLength(string.length),\n            size: 5\n        }\n\n        // If all characters are not writeable due to insufficient bits\n        // remaining etc., then return empty string.\n        let writeable = this.#writeable()\n            .append(resize.value, { ...resize })\n            .append(string.length)\n        for (let i = 0; i < string.length; i++) {\n            writeable = writeable.append(0, { size: 8 })\n        }\n        if (!writeable.isWriteable) { return \"\" }\n\n        // Write string length declaration and string to buffer.\n        this.#write(resize.value, { ...resize, offset })\n        this.#write(string.length)\n        for (const char of string) {\n            this.#write(char.charCodeAt(0), { size: 8 })\n        }\n\n        return string\n    }\n\n    /**\n     * Read an integer directly from internal buffer, updating read pointers to\n     * the end of the read data.\n     *\n     * @param {number} size - Size of buffer segment to read.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    read(size, { offset = this.#readPointer, signed = false } = {}) {\n        // If all values are not readable due to insufficient bits remaining\n        // etc., then return no number.\n        const readable = this.#readable().append(size, { offset, signed })\n        if (!readable.isReadable) { return NaN }\n\n        return this.#read(size, { offset, signed })\n    }\n\n    /**\n     * Read an integer from internal buffer, determining bit size of segment\n     * by reading an absolute size declaration from the buffer indicating how\n     * many bits should be read (i.e. 5 additional bits read before reading\n     * integer to determine bit size of read segment between 0 and 32 bits).\n     * Update read pointers to the end of the read data.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    readAbsolute({ offset = this.#readPointer, signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer\n        const lastReadSize = this.#lastReadSize\n\n        // Check if sufficient read bits remain to read both the size\n        // declaration and integer.\n        const readable = this.#readable().append(5, { offset })\n        let size = 0\n        if (readable.isReadable) {\n            size = this.#read(5, { offset })\n            readable.append(size, { signed })\n        }\n\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer\n            this.#lastReadSize = lastReadSize\n            return NaN\n        }\n\n        return this.#read(size, { signed })\n    }\n\n    /**\n     * Read an integer from internal buffer, determining bit size of segment by\n     * reading a relative size declaration from the buffer indicating how many\n     * bit should be read (i.e. 1 \"sign\" bit to indicate if more or less bits\n     * than the previous read call are being read, and n \"0\" bits where n is the\n     * relative size between the previous and next read call sizes). Update read\n     * pointers to the end of the read data.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    readRelative({ offset = this.#readPointer, signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer\n        const lastReadSize = this.#lastReadSize\n\n        // Get sign of relative size (i.e. are more or less bits to be read than\n        // last read call).\n        let sign = 1\n        const readable = this.#readable().append(1, { offset })\n        if (readable.isReadable) { sign = this.#read(1, { offset }) ? 1 : - 1 }\n\n        // Get unsigned read size relative to size of last read call (reads\n        // until first bit of integer to be read, then breaks).\n        let relativeSize = 0\n        while (readable.append(1).isReadable) {\n            if (this.#read(1)) { break }\n            relativeSize++\n        }\n\n        // Get size of integer to be read from buffer.\n        const size = lastReadSize + sign * relativeSize\n        readable.append(size, { signed })\n\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer\n            this.#lastReadSize = lastReadSize\n            return NaN\n        }\n\n        // Decrement read pointer to account for first bit of integer having\n        // been read above.\n        this.#readPointer--\n\n        return this.#read(size, { signed })\n    }\n\n    /**\n     * Read a string of arbitrary length from the internal buffer.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @returns {string} String read from buffer.\n     */\n    readString({ offset = this.#readPointer } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer\n        const lastReadSize = this.#lastReadSize\n\n        // Get bit size of string length declaration.\n        const readable = this.#readable().append(5, { offset })\n        let lengthSize = 0\n        if (readable.isReadable) { lengthSize = this.#read(5, { offset }) }\n        readable.append(lengthSize)\n\n        // Get string length.\n        let length = 0\n        if (readable.isReadable) { length = this.#read(lengthSize) }\n\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !length) {\n            this.#readPointer = readPointer\n            this.#lastReadSize = lastReadSize\n            return \"\"\n        }\n\n        let string = \"\"\n        for (let i = 0; i < length; i++) {\n            // Ensure next byte (8 bit character) is readable.\n            readable.append(8)\n\n            // Reset pointers and return no number if insufficient remaining\n            // read bits.\n            if (!readable.isReadable) {\n                this.#readPointer = readPointer\n                this.#lastReadSize = lastReadSize\n                return \"\"\n            }\n\n            // Read character from buffer and append to string.\n            string += String.fromCharCode(this.#read(8))\n        }\n\n        return string\n    }\n\n    /**\n     * Copy data from source buffer (current buffer instance) to a target buffer\n     * passed in the arguments. If no target buffer passed, new BitBuffer\n     * instantiated with a length based on number of copied bits. Will update\n     * read/write pointers in both source and target buffers.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {BitBuffer} [obj.target] - Target buffer to copy to.\n     * @param {number} [obj.targetStart] - Start bit in target buffer.\n     * @param {number} [obj.sourceStart] - Start bit in source buffer.\n     * @param {number} [obj.sourceEnd] - End bit in source buffer.\n     * @returns {BitBuffer} Target buffer with data copied from source buffer.\n     */\n    copy({\n        target,\n        targetStart = target?.writePointer || 0,\n        sourceStart = 0,\n        sourceEnd = this.bitLength\n    } = {}) {\n        // Throw error if source start or end bounds are out of buffer range.\n        if (sourceStart < 0 || sourceEnd > this.bitLength) {\n            throw new DecoratedError({\n                name: \"BitBufferError\",\n                message: \"Requested bits out of source buffer range\",\n                \"source-start\": sourceStart,\n                \"source-end\": sourceEnd,\n                \"source-bit-length\": this.bitLength\n            })\n        }\n\n        // Get number of source bits, and minimum size of target buffer in bytes\n        // to store the data from the source buffer.\n        const sourceBits = sourceEnd - sourceStart\n        const targetSize = Math.ceil((sourceBits + targetStart) / 8)\n\n        // Get available write bits in target buffer, instantiating a BitBuffer\n        // of the correct size if none is passed in arguments.\n        target ??= new BitBuffer({ size: targetSize })\n        const targetBits = target.bitLength - targetStart\n\n        // Throw error if not sufficient bits remaining in target buffer.\n        if (sourceBits > targetBits) {\n            throw new DecoratedError({\n                name: \"BitBufferError\",\n                message: \"Source bits exceed bits available in target buffer\",\n                \"source-bits\": sourceBits,\n                \"target-bits\": targetBits\n            })\n        }\n\n        // Copy data bits from source buffer to target buffer.\n        for (let i = 0; i < sourceBits; i++) {\n            target.write(\n                this.#read(1, { offset: sourceStart + i }),\n                { size: 1, offset: targetStart + i }\n            )\n        }\n\n        return target\n    }\n\n    /**\n     * Convert buffer to serialized string of base-64 url-safe characters.\n     *\n     * @returns {string} Serialized buffer string.\n     */\n    toString() {\n        // Initialize serialized string and pointers to track string fragments.\n        let string = \"\"\n        let pointer = 0\n        let uint24 = 0\n\n        // Loop over buffer, adding 4 character fragments to serialized string\n        // for every 24 bits consumed from buffer (24-bit blocks consumed in\n        // 3-byte blocks at time).\n        const view = new Uint8Array(this.#buffer)\n        for (let i = 0; i < Math.ceil(this.byteLength / 3) * 3; i++) {\n            const byte = view[i] || 0\n            uint24 = (uint24 | (byte << 16 - pointer * 8)) >>> 0\n            pointer = ++pointer % 3\n            if (!pointer) {\n                string += BitBuffer.#uint24ToB64(uint24)\n                uint24 = 0\n            }\n        }\n\n        return string\n    }\n\n    /**\n     * Create object containing\n     */\n    #writeable() {\n        //\n        const tracer = { writeable: true, offset: this.#writePointer }\n\n        /**\n         *\n         * @param {number} int\n         * @param {object} obj\n         * @param {number} [obj.size]\n         * @param {number} [obj.offset]\n         * @param {boolean} [obj.signed]\n         */\n        const append = (int, {\n            size = BitBuffer.#bitLength(int),\n            offset = tracer.offset,\n            signed = false\n        } = {}) => {\n            if (tracer.writeable) {\n                const uint32 = Math.abs(int)\n                const bitsRemaining = this.bitLength - offset\n\n                tracer.writeable = !signed && int < 0 ? false\n                    : BitBuffer.#bitLength(uint32) > size ? false\n                    : !Number.isInteger(uint32) ? false\n                    : size < 0 || size > 32 ? false\n                    : size + (signed ? 1 : 0) > bitsRemaining ? false\n                    : true\n            }\n\n            tracer.offset += size\n\n            return { append, get isWriteable() { return tracer.writeable } }\n        }\n\n        return { append, get isWriteable() { return tracer.writeable } }\n    }\n\n    /**\n     * Write sanitized integer directly to internal buffer, updating write\n     * pointers to the end of the written data. This private method is called by\n     * other class write methods *after* values have been checked to ensure that\n     * they are not out of range, or will not fit in the remaining empty buffer\n     * bits.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.size] - Size of buffer segment to write in bits.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    #write(int, {\n        size = BitBuffer.#bitLength(int),\n        offset = this.#writePointer,\n        signed = false\n    } = {}) {\n        // Get absolute value of integer to write.\n        const uint32 = Math.abs(int)\n\n        const { view, byteLength, subBit } = this.#getView(size, offset)\n        for (let i = 0; i < byteLength; i++) {\n            const byte = view.getUint8(i)\n            let uint8 = 0\n            for (let j = 0; j < 8; j++) {\n                const index = i * 8 + j\n                const bit = index < subBit || index > subBit + size\n                    ? byte << 24 + j >>> 31\n                    : uint32 << (32 - size) + (index - subBit) >>> 31\n                uint8 = uint8 | (bit << 7 - j)\n            }\n            view.setUint8(i, uint8)\n        }\n\n        // Update write pointer and add sign bit *after* written integer.\n        // NOTE: The sign bit is written at the end of integers in the BitBuffer\n        // as this saves a bit when using the writeRelative and readRelative\n        // methods. This is because the relative size declaration can be assumed\n        // to end at the first non-zero bit (i.e. the start of the number),\n        // rather than requiring an extra \"1\" end bit if the \"1\"/\"0\" sign bit\n        // was written at the start of the number.\n        this.#writePointer = offset + size\n        if (signed) { this.#write(int >= 0 ? 1 : 0, { size: 1 }) }\n\n        // Update last write size *after* sign bit such that the sign bit is\n        // *not* considered as the last integer size written.\n        this.#lastWriteSize = size\n\n        return int\n    }\n\n    /**\n     *\n     */\n    #readable() {\n        const tracer = { readable: true, offset: this.#readPointer }\n\n        const append = (/** @type {number} */ size, {\n            offset = tracer.offset,\n            signed = false\n        } = {}) => {\n            if (tracer.readable) {\n                const bitsRemaining = this.bitLength - offset\n\n                tracer.readable = size < 0 || size > 32 ? false\n                    : size + (signed ? 1 : 0) > bitsRemaining ? false\n                    : true\n            }\n\n            tracer.offset += size\n\n            return { append, get isReadable() { return tracer.readable } }\n        }\n\n        return { append, get isReadable() { return tracer.readable } }\n    }\n\n    /**\n     * Read sanitized integer directly from internal buffer, updating write\n     * pointers to the end of the read data. This private method is called by\n     * other class read methods *after* values have been checked to ensure that\n     * they are not out of range.\n     *\n     * @param {number} size - Size of buffer segment to read.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    #read(size, { offset = this.#readPointer, signed = false } = {}) {\n        const { view, byteLength, subBit } = this.#getView(size, offset)\n        let uint32 = 0\n        for (let i = 0; i < byteLength; i++) {\n            const offset = 24 + subBit - i * 8\n            uint32 = offset >= 0\n                ? (uint32 | view.getUint8(i) << offset) >>> 0\n                : (uint32 | view.getUint8(i) >>> - offset) >>> 0\n        }\n\n        this.#readPointer = offset + size\n        const sign = signed && this.#read(1) === 0 ? - 1 : 1\n\n        this.#lastReadSize = size\n\n        return sign * (uint32 >>> 32 - size)\n    }\n\n    /**\n     *\n     * @param {*} size\n     * @param {*} offset\n     * @returns {{view:DataView,byteLength:number,subBit:number}} Object\n     *      containing requested dataview of BitBuffer at the given offset.\n     */\n    #getView(size, offset) {\n        const startByte = Math.floor(offset / 8)\n        const subBit = offset - 8 * startByte\n        const byteLength = Math.ceil((subBit + size) / 8)\n        if (startByte + byteLength > this.byteLength) {\n            // throw new BitBuffer.#RangeError(size, offset)\n        }\n        const view = new DataView(this.#buffer, startByte, byteLength)\n        return { view, byteLength, subBit }\n    }\n\n    /**\n     * Get length of buffer in bits.\n     *\n     * @returns {number} Bit length of buffer.\n     */\n    get bitLength() { return this.byteLength << 3 }\n\n    /**\n     * Get length of buffer in bytes.\n     *\n     * @returns {number} Byte length of buffer.\n     */\n    get byteLength() { return this.#buffer.byteLength }\n\n    /**\n     * Get current read pointer.\n     *\n     * @returns {number} Internal read pointer.\n     */\n    get readPointer() { return this.#readPointer }\n\n    /**\n     * Safely set current read pointer, observing bit size of buffer.\n     *\n     * @param {number} pointer - Updated read pointer.\n     * @returns {void}\n     */\n    set readPointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) { return }\n\n        // Update internal pointer.\n        this.#readPointer = pointer\n    }\n\n    /**\n     * Get last read size in bits.\n     *\n     * @returns {number} Internal last read size in bits.\n     */\n    get lastReadSize() { return this.#lastReadSize }\n\n    /**\n     * Safely set last read size, observing max and min integer bit sizes.\n     *\n     * @param {number} size - Updated last read size in bits.\n     * @returns {void}\n     */\n    set lastReadSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) { return }\n\n        // Update internal read size.\n        this.#lastReadSize = size\n    }\n\n    /**\n     * Get current write pointer.\n     *\n     * @returns {number} Internal write pointer.\n     */\n    get writePointer() { return this.#writePointer }\n\n    /**\n     * Safely set current write pointer, observing bit size of buffer.\n     *\n     * @param {number} pointer - Updated write pointer.\n     * @returns {void}\n     */\n    set writePointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) { return }\n\n        // Update internal pointer.\n        this.#writePointer = pointer\n    }\n\n    /**\n     * Get last write size in bits.\n     *\n     * @returns {number} Internal last write size in bits.\n     */\n    get lastWriteSize() { return this.#lastWriteSize }\n\n    /**\n     * Safely set last write size, observing max and min integer bit sizes.\n     *\n     * @param {number} size - Updated last write size in bits.\n     * @returns {void}\n     */\n    set lastWriteSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) { return }\n\n        // Update internal write size.\n        this.#lastWriteSize = size\n    }\n\n    /**\n     * Decode serialized url-safe base 64 BitBuffer string, returning a new\n     * BitBuffer instance containing the data from the original serialized\n     * buffer.\n     *\n     * @param {string} string - Url-safe base 64 encoded BitBuffer string.\n     * @returns {BitBuffer} Decoded BitBuffer instance.\n     */\n    static from(string) {\n        // Throw error if input string not correctly encoded.\n        if (!string.match(/^[A-Za-z0-9\\-_]*$/)) {\n            throw new DecoratedError({\n                name: \"BitBufferError\",\n                message: \"Encoded string is not url-safe base 64 encoded\",\n                \"encoded-string\": string\n            })\n        }\n\n        // Create new BitBuffer instance based on length of input string.\n        const buffer = new BitBuffer({ size: Math.ceil(string.length * 3 / 4) })\n\n        // Split input string into 4-character segments, convert each segment\n        // into 24-bit unsigned integer, and write to new BitBuffer instance.\n        const regex = /[A-Za-z0-9\\-_]{1,4}/g\n        for (const match of string.match(regex) || []) {\n            const uint24 = BitBuffer.#b64ToUint24(match.padEnd(4, \"A\"))\n            buffer.write(uint24, { size: 24 })\n        }\n\n        // Reset read and write pointers.\n        buffer.writePointer = 0\n        buffer.readPointer = 0\n\n        return buffer\n    }\n\n    /**\n     * Convert 4 character url-safe base 64 string to 24-bit unsigned integer.\n     *\n     * @param {string} string - 4 character url-safe base 64 string.\n     * @returns {number} Unsigned 24 bit integer.\n     */\n    static #b64ToUint24(string) {\n        let uint24 = 0\n\n        // Loop over characters of input string, converting each url-safe base\n        // 64 character to a 6-bit integer. Bitwise SHIFT the result such that\n        // the 6 data bits occupy a unique sector of the uint24 output, and\n        // bitwise AND the result with the uint24 output.\n        for (const [index, char] of string.split(\"\").entries()) {\n            const uint6 = BitBuffer.#dict.indexOf(char)\n            uint24 = (uint24 | (uint6 << 18 - index * 6)) >>> 0\n        }\n\n        return uint24\n    }\n\n    /**\n     * Convert 24-bit unsigned integer to 4 character url-safe base 64 string.\n     *\n     * @param {number} uint24 - Unsigned 24 bit integer.\n     * @returns {string} 4 character url-safe base 64 string.\n     */\n    static #uint24ToB64(uint24) {\n        let string = \"\"\n\n        // Divide 24-bit integer into 6-bit segments, appending a url-safe base\n        // 64 character to output string for each segment.\n        for (let i = 0; i < 4; i++) {\n            const uint6 = uint24 >>> 18 - i * 6 << 26 >>> 26\n            string += BitBuffer.#dict[uint6]\n        }\n\n        return string\n    }\n\n    /**\n     * Get bit length of a given number.\n     *\n     * @param {number} value - Input number.\n     * @returns {number} Bit length.\n     */\n    static #bitLength(value) { return Math.abs(value).toString(2).length }\n\n    /**\n     * Get url-safe base64 character dictionary, which uses different padding\n     * characters to the standard base64 encoding in node. Please see\n     * [here](https://developer.mozilla.org/en-US/docs/Glossary/Base64) for more\n     * information on base64 encoding. For url safe characters, see rfc4648\n     * [here](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @returns {string} Url-safe base64 dictionary string.\n     */\n    static get #dict() {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + // Uppercase alpha characters.\n            \"abcdefghijklmnopqrstuvwxyz\" + // Lowercase alpha characters.\n            \"0123456789\" + // Number characters.\n            \"-_\" // Url-safe padding characters for total of 64 characters.\n    }\n}\n\n// @@exports\nexport { BitBuffer }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Class for managing multiple workers up to a specified limit.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n// note that shared workers are not possible due to not being currently\n// available in chrome for android https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker @no-wrap\nclass WorkerManager {\n    #queue = /** @type {{message:any, callback:(event:any)=>void}[]} */ ([])\n    #workers = /** @type {Map.<Worker, number>} */ (new Map())\n    #instantiateWorker\n    #limit\n\n    /**\n     *\n     * @param {()=>Worker} callback\n     * @param {object} obj\n     * @param {number} [obj.limit]\n     */\n    constructor(callback, { limit = 4 } = {}) {\n        this.#instantiateWorker = callback\n        this.#limit = limit\n    }\n\n    /**\n     *\n     * @returns {Worker}\n     */\n    addWorker() {\n        const worker = this.#instantiateWorker()\n        this.#workers.set(worker, NaN)\n        return worker\n    }\n\n    /**\n     *\n     * @param {Worker} worker\n     * @param {any} message\n     * @param {(event:any)=>void} callback\n     */\n    postWorker(worker, message, callback) {\n        this.#workers.set(worker, NaN)\n        worker.onmessage = event => {\n            this.#dequeue(worker)\n            callback(event)\n        }\n        worker.postMessage(message)\n    }\n\n    /**\n     *\n     * @param {any} message\n     * @param {(event:any)=>void} callback\n     */\n    enqueue(message, callback) {\n        let /** @type {Worker|undefined} */ worker\n        for (const [existingWorker, timeLastActive] of this.#workers) {\n            if (timeLastActive) {\n                worker = existingWorker\n                break\n            }\n        }\n\n        if (worker) { this.postWorker(worker, message, callback) }\n        else if (this.#workers.size < this.#limit) {\n            worker = this.addWorker()\n            this.postWorker(worker, message, callback)\n        }\n        else { this.#queue.push({ message, callback }) }\n    }\n\n    /**\n     *\n     * @param {Worker} worker\n     */\n    #dequeue(worker) {\n        const { message, callback } = this.#queue.shift() || {}\n        if (message && callback) {\n            this.postWorker(worker, message, callback)\n        }\n        else {\n            this.#workers.set(worker, Date.now())\n            setTimeout(() => {\n                const timeLastActive = /** @type {number} */\n                    (this.#workers.get(worker))\n                if (Date.now() - timeLastActive > 1000) {\n                    worker.terminate()\n                    this.#workers.delete(worker)\n                }\n            }, 1050)\n        }\n    }\n}\n\n// @@exports\nexport { WorkerManager }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Colorspace conversions for jpg dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n * Clamp and optionally round input number between a minimum and maximum value.\n *\n * @param {number} number - Input number.\n * @param {number} minimum - Minimum value which will be returned.\n * @param {number} maximum - Maximum value which will be returned.\n * @param {boolean} isInt - Should returned value be an integer?\n * @returns {number} Clamped value.\n */\nconst clamp = (number, minimum = 0, maximum = 255, isInt = true) => {\n    // If should return integer, round arguments whilst respecting maximum and\n    // minimum sense of bounds (i.e. do not round minimum down or maximum up\n    // which allows numbers to be returned outside of clamp bounds).\n    if (isInt) {\n        number = Math.round(number)\n        minimum = Math.ceil(minimum)\n        maximum = Math.floor(maximum)\n    }\n\n    // Return clamped number.\n    return Math.max(minimum, Math.min(maximum, number))\n}\n\n/**\n * Convert rgb (red, green, blue) color value to YCbCr (luma, chroma blue,\n * chroma red) color value for use in jpg dct compression. Please see [this\n * section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} red - Red value of color between 0 and 255.\n * @param {number} green - Green value of color between 0 and 255.\n * @param {number} blue - Blue value of color between 0 and 255.\n * @returns {{luma:number, chromaBlue:number, chromaRed:number}} Color converted\n *      to YCbCr.\n */\nconst rgbToYCbCr = (red, green, blue) => {\n    // Clamp input channels to values between 0 and 255.\n    red = clamp(red)\n    green = clamp(green)\n    blue = clamp(blue)\n\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        luma: clamp(0.30 * red + 0.59 * green + 0.11 * blue),\n        chromaBlue: clamp(128 - 0.17 * red - 0.33 * green + 0.50 * blue),\n        chromaRed: clamp(128 + 0.50 * red - 0.42 * green - 0.08 * blue)\n    }\n}\n\n/**\n * Convert 4-channel rgba (red, green, blue, alpha) buffer into a 3-channel\n * YCbCr (luma, chroma blue, chroma red) flat data array.\n *\n * @param {Buffer} rgbaBuffer - 4-channel, rgba formatted buffer.\n * @returns 3-channel, YCbCr formatted flat data array.\n */\nconst rgbaBufferToYCbCrArray = rgbaBuffer => {\n    // Initialise flat output data array.\n    const yCbCrArray = []\n\n    // Loop over input data array, fetching the luma, chroma blue, and chroma\n    // red values from the red, green, and blue input data values. Skip alpha\n    // channel, and push converted pixel data to the output array.\n    for (let i = 0; i < rgbaBuffer.length; i += 4) {\n        const { luma, chromaBlue, chromaRed } = rgbToYCbCr(\n            rgbaBuffer[i],\n            rgbaBuffer[i + 1],\n            rgbaBuffer[i + 2]\n        )\n        yCbCrArray.push(luma, chromaBlue, chromaRed)\n    }\n\n    return yCbCrArray\n}\n\n/**\n * Convert YCbCr (luma, chroma blue, chroma red) color value to rgb (red, green,\n * blue) color value for use in reversing colorspace used in jpg dct. Please see\n * [this section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} luma - Luma value of color between 0 and 255.\n * @param {number} chromaBlue - Chroma blue value of color between 0 and 255.\n * @param {number} chromaRed - Chroma red value of color between 0 and 255.\n * @returns {{red:number, green:number, blue:number}} Color converted to rgb.\n */\nconst yCbCrToRgb = (luma, chromaBlue, chromaRed) => {\n    // Clamp input channels to values between 0 and 255.\n    luma = clamp(luma)\n    chromaBlue = clamp(chromaBlue)\n    chromaRed = clamp(chromaRed)\n\n    // Rectify chroma values such that they are between -128 and +128.\n    chromaBlue -= 128\n    chromaRed -= 128\n\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        red: clamp(luma + 1.40 * chromaRed),\n        green: clamp(luma - 0.34 * chromaBlue - 0.71 * chromaRed),\n        blue: clamp(luma + 1.77 * chromaBlue)\n    }\n}\n\n/**\n * Convert 3-channel YCbCr (luma, chroma blue, chroma red) flat data array into\n * 4-channel rgba (red, green, blue, alpha) flat data array.\n *\n * @param {number[]} yCbCrArray - 3-channel, YCbCr formatted flat data array.\n * @returns 4-channel, rgba formatted flat data array.\n */\nconst yCbCrArrayToRgbaArray = (yCbCrArray, alpha = 255) => {\n    // Initialise flat output data array.\n    const rgbaArray = []\n\n    // Loop over input data array, fetching the red, green, and blue values from\n    // the luma, chroma blue, and chroma red input data values. Push converted\n    // pixel data to the output array with extra alpha channel.\n    for (let i = 0; i < yCbCrArray.length; i += 3) {\n        const { red, green, blue } = yCbCrToRgb(\n            yCbCrArray[i],\n            yCbCrArray[i + 1],\n            yCbCrArray[i + 2]\n        )\n        rgbaArray.push(red, green, blue, alpha)\n    }\n\n    return rgbaArray\n}\n\n// @@exports\nexport { rgbToYCbCr, rgbaBufferToYCbCrArray, yCbCrToRgb, yCbCrArrayToRgbaArray }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Methods for decoding pixel arrays using dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { BlurridMetadata } from \"./BlurridMetadata.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n/**\n *\n * @param {number[][][]} array3D\n * @param {BlurridMetadata} metadata\n * @returns {number[][][]}\n */\nconst decodePixelArray3D = (array3D, metadata) => {\n    const [lumaDct, chromaBlueDct, chromaRedDct] = array3D\n\n    const emptyChannel = () => {\n        return Array.from(\n            Array.from({ length: metadata.image.height }),\n            () => Array.from({ length: metadata.image.width }).fill(0)\n        )\n    }\n\n    const channels = [emptyChannel(), emptyChannel(), emptyChannel()]\n    const [lumaChannel, chromaBlueChannel, chromaRedChannel] = channels\n\n    for (let y = 0; y < metadata.image.height; y++) {\n        for (let x = 0; x < metadata.image.width; x++) {\n            const point = {\n                x: x / metadata.image.width * metadata.sample.width,\n                y: y / metadata.image.height * metadata.sample.height\n            }\n\n            lumaChannel[y][x] = decodePixelArray2D(lumaDct, point, metadata)\n            chromaBlueChannel[y][x] =\n                decodePixelArray2D(chromaBlueDct, point, metadata)\n            chromaRedChannel[y][x] =\n                decodePixelArray2D(chromaRedDct, point, metadata)\n        }\n    }\n\n    return channels\n}\n\n/**\n *\n * @param {number[][]} array2D\n * @param {{x:number, y:number}} point\n * @param {BlurridMetadata} metadata\n * @returns\n */\nconst decodePixelArray2D = (array2D, point, metadata) => {\n    const dctRow = []\n\n    for (let i = 0; i < metadata.sample.width; i++) {\n        const dctColumn = array2D[i]\n        dctRow.push(decodePixelArray1D(dctColumn, point.y))\n    }\n\n    return decodePixelArray1D(dctRow, point.x)\n}\n\n// note in this implementation radians is always supplied +ve\n/**\n *\n * @param {number} radians - Angle value in radians, note that in this\n *      implementation the angle is *always* provided as a positive value.\n * @returns {number}\n */\nconst fastCos = radians => {\n    // Rectify angle value to between 0 and 2PI radians using custom mod (while\n    // loop faster than builtin javascript `%` mod operator)\n    while (radians >= Math.PI * 2) { radians -= Math.PI * 2 }\n\n    // Rectify angle value to between 0 and PI radians (note that since angle\n    // value is *always* supplied as a positive value in this implementation,\n    // rectifying to a positive value is not required).\n    if (radians > Math.PI) { radians = 2 * Math.PI - radians }\n\n    // Execute fastCos formula using a rearranged Bhaskara sine approximation\n    // (see here for more https://en.wikipedia.org/wiki/Bh%C4%81skara_I%27s_sine_approximation_formula) @no-wrap\n    if (radians > Math.PI / 2) {\n        radians = (radians - Math.PI) * (radians - Math.PI)\n        return 5 * radians / (radians + Math.PI * Math.PI) - 1\n    }\n    radians *= radians\n    return 1 - 5 * radians / (radians + Math.PI * Math.PI)\n}\n\n/**\n *\n * @param {number[]} array1D\n * @param {number} pointX\n * @returns {number}\n */\nconst decodePixelArray1D = (array1D, pointX) => {\n    let result = 0\n    for (let i = 0; i < array1D.length; i++) {\n        let partial = array1D[i] * fastCos(\n            ((2 * pointX + 1) * Math.PI * i) / (2 * array1D.length)\n        )\n        partial *= i === 0 ? Math.SQRT1_2 : 1\n        result += partial\n    }\n    result *= Math.sqrt(2 / array1D.length)\n    result = Math.round(result)\n    return result\n}\n\n// @@exports\nexport { decodePixelArray3D }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Global variables for buffer start locations for certain data.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\nconst BUFFER_LOCATIONS = {\n    METADATA: 0,\n    SUBSAMPLING: 48,\n    COEFFICIENTS: 57,\n    ASSUMED_COEFFICIENT_SIZE: 8\n}\n\n// @@exports\nexport { BUFFER_LOCATIONS }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Wrapper class around blurrid dct encoding functions.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\nimport { expandSample } from \"./array-conversions.js\"\nimport { BlurridMetadata } from \"./BlurridMetadata.js\"\nimport { rgbaBufferToYCbCrArray } from \"./colorspace-conversions.js\"\nimport { consumeDctArray3D } from \"./consumers.js\"\nimport { encodePixelArray3D } from \"./encode.js\"\nimport { BUFFER_LOCATIONS } from \"./serialize.js\"\nimport { SubsampleSelector } from \"./SubsampleSelector.js\"\n\n// @@imports-utils\nimport { BitBuffer } from \"../utils/index.js\"\n\n// @@body\nclass BlurridEncoder {\n    #metadata\n    #buffer\n\n    /**\n     *\n     * @param {object} obj\n     * @param {Buffer} obj.buffer\n     * @param {number} obj.width\n     * @param {number} obj.height\n     */\n    constructor({ buffer, width, height }) {\n        const ratio = Math.min(width, height) / Math.max(width, height)\n        const samples = Math.round(Math.sqrt(buffer.length / (4 * ratio)))\n\n        const secondarySamples = buffer.length / 4 / samples\n        const { sampleWidth, sampleHeight } = width > height\n            ? { sampleWidth: samples, sampleHeight: secondarySamples }\n            : { sampleWidth: secondarySamples, sampleHeight: samples }\n\n        const image = { width, height }\n        const sample = { width: sampleWidth, height: sampleHeight }\n        this.#metadata = new BlurridMetadata({ image, sample })\n        this.#buffer = buffer\n    }\n\n    toString({ length = 64, subsampling = \"4:2:2\" } = {}) {\n        //\n        const buffer = new BitBuffer({ length })\n        const subsampleSelector = new SubsampleSelector(subsampling)\n\n        //\n        this.#serializeMetadata(buffer)\n        this.#serializeSubsampling(buffer, subsampleSelector)\n        this.#serializeCoefficients(buffer, subsampleSelector)\n\n        return buffer.toString()\n    }\n\n    /**\n     *\n     * @param {BitBuffer} buffer\n     */\n    #serializeMetadata(buffer) {\n        //\n        buffer.writePointer = BUFFER_LOCATIONS.METADATA\n\n        //\n        buffer.write(this.#metadata.image.width, { size: 16 })\n        buffer.write(this.#metadata.image.height, { size: 16 })\n        buffer.write(this.#metadata.sample.width, { size: 8 })\n        buffer.write(this.#metadata.sample.height, { size: 8 })\n    }\n\n    /**\n     *\n     * @param {BitBuffer} buffer\n     * @param {SubsampleSelector} subsampleSelector\n     */\n    #serializeSubsampling(buffer, subsampleSelector) {\n        //\n        buffer.writePointer = BUFFER_LOCATIONS.SUBSAMPLING\n\n        buffer.write(subsampleSelector.luma, { size: 3 })\n        buffer.write(subsampleSelector.chromaBlue, { size: 3 })\n        buffer.write(subsampleSelector.chromaRed, { size: 3 })\n    }\n\n    /**\n     *\n     * @param {BitBuffer} buffer\n     * @param {SubsampleSelector} subsampleSelector\n     */\n    #serializeCoefficients(buffer, subsampleSelector) {\n        //\n        buffer.writePointer = BUFFER_LOCATIONS.COEFFICIENTS\n        buffer.lastWriteSize = BUFFER_LOCATIONS.ASSUMED_COEFFICIENT_SIZE\n        for (const coefficient of this.#dctConsumer(subsampleSelector)) {\n            const written = buffer.writeRelative(coefficient, { signed: true })\n            if (isNaN(written)) { break }\n        }\n    }\n\n    /**\n     *\n     * @param {SubsampleSelector} subsampleSelector\n     * @returns\n     */\n    #dctConsumer(subsampleSelector) {\n        const yCbCrArray = rgbaBufferToYCbCrArray(this.#buffer)\n        const array3D = expandSample(yCbCrArray, this.#metadata.sample.width)\n\n        return consumeDctArray3D(encodePixelArray3D(array3D), subsampleSelector)\n    }\n}\n\n// @@exports\nexport { BlurridEncoder }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Generator for consuming arrays of dct coefficients.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-utils\nimport { DecoratedError } from \"../utils/index.js\"\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { SubsampleSelector } from \"./SubsampleSelector.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n/**\n *\n * @param {number[][][]} array3D\n * @param {SubsampleSelector} subsampleSelector\n */\nfunction* consumeDctArray3D(array3D, subsampleSelector) {\n    const [lumaArray2D, chromaBlueArray2D, chromaRedArray2D] = array3D\n    const consumers = {\n        luma: consumeDctArray2D(lumaArray2D),\n        chromaBlue: consumeDctArray2D(chromaBlueArray2D),\n        chromaRed: consumeDctArray2D(chromaRedArray2D)\n    }\n\n    let index = 0\n    do {\n        const iteration = consumers[subsampleSelector.key(index)].next()\n        if (iteration.done) { break }\n        yield iteration.value\n    } while (++index)\n}\n\n// consume 2d array from diagonal\n/**\n *\n * @param {number[][]} array2D - 2D array of dct coefficients (the 2D array will\n *      be one subsample\n *      from luma, or each chrominance).\n */\nfunction* consumeDctArray2D(array2D) {\n    const [width, height] = [array2D[0].length, array2D.length]\n    for (const coefficientRow of array2D) {\n        if (coefficientRow.length !== width) {\n            throw new DecoratedError({\n                name: \"DctError\",\n                message: \"Coefficient row width does not match image width\",\n                \"image-width\": length,\n                \"row-width\": coefficientRow.length\n            })\n        }\n    }\n    let [x, y] = [0, 0]\n\n    while (true) {\n        yield array2D[y][x]\n\n        if (y === 0 || x === width - 1) {\n            const sum = x + y + 1\n            if (sum > width + height - 2) { break }\n            y = x >= height - 1 ? height - 1 : x + 1\n            x = sum - y\n        }\n        else { y--; x++ }\n    }\n}\n\n// @@exports\nexport { consumeDctArray3D }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Methods for encoding pixel arrays using dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n *\n * @param {number[][][]} array3D\n * @returns {number[][][]}\n */\nconst encodePixelArray3D = array3D => {\n    return array3D.map(encodePixelArray2D)\n}\n\n/**\n * add errors for inconsistent widths\n *\n * @param {number[][]} array2D\n * @returns {number[][]}\n */\nconst encodePixelArray2D = array2D => {\n    /** @type {number[][]} */\n    const primaryEncodedArray2D = []\n    for (let i = 0; i < array2D.length; i++) {\n        primaryEncodedArray2D.push(encodePixelArray1D(array2D[i]))\n    }\n\n    /** @type {number[][]} */\n    const secondaryEncodedArray2D = Array.from(\n        Array.from({ length: primaryEncodedArray2D.length }),\n        () => []\n    )\n    for (let i = 0; i < primaryEncodedArray2D[0].length; i++) {\n        const column = []\n        for (let j = 0; j < primaryEncodedArray2D.length; j++) {\n            column.push(primaryEncodedArray2D[j][i])\n        }\n        for (const [j, coefficient] of encodePixelArray1D(column).entries()) {\n            secondaryEncodedArray2D[j].push(coefficient)\n        }\n    }\n\n    return secondaryEncodedArray2D\n}\n\n/**\n *\n * @param {number[]} array1D\n * @returns {number[]}\n */\nconst encodePixelArray1D = array1D => {\n    const coefficients = []\n    for (let i = 0; i < array1D.length; i++) {\n        let coefficient = 0\n        for (let j = 0; j < array1D.length; j++) {\n            coefficient += array1D[j] * Math.cos(\n                ((2 * j + 1) * Math.PI * i) / (2 * array1D.length)\n            )\n        }\n        coefficient *= Math.sqrt(2 / array1D.length)\n        coefficient *= i === 0 ? Math.sqrt(0.5) : 1\n        coefficients.push(Math.round(coefficient))\n    }\n    return coefficients\n}\n\n// @@exports\nexport { encodePixelArray3D }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Export shader methods for generating image blur placeholders on web.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@no-body\n\n// @@exports\nexport * from \"./canvas.js\"\nexport * from \"./decode.js\"\nexport * from \"./worker-instance.js\"\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Methods for generating webgl and context2d canvas elements.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\n// @ts-expect-error: File is a glsl shader which will be loaded by rollup.\nimport vertexSource from \"./shader.vert\"\n// @ts-expect-error: File is a glsl shader which will be loaded by rollup.\nimport fragmentSource from \"./shader.frag\"\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { BlurridMetadata } from \"../dct/index.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n/**\n *\n * @param {BlurridMetadata} metadata\n * @returns {{canvas:HTMLCanvasElement, context:WebGLRenderingContext, program:WebGLProgram}} @no-wrap\n */\nconst getCanvasWebGL = metadata => {\n    //\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = metadata.image.width\n    canvas.height = metadata.image.height\n\n    //\n    const context = /** @type {WebGLRenderingContext} */\n        (canvas.getContext(\"webgl\"))\n\n    const shaders = {\n        vertex: getShader(context, context.VERTEX_SHADER, vertexSource),\n        fragment: getShader(context, context.FRAGMENT_SHADER, fragmentSource, {\n            SAMPLE_WIDTH: metadata.sample.width,\n            SAMPLE_HEIGHT: metadata.sample.height,\n            SAMPLE_MAX: metadata.sample.max,\n            SAMPLE_NORMALIZED_TOTAL: metadata.sample.max ** 2\n        })\n    }\n\n    const program = getProgram(context, shaders)\n\n    const vertexData = {\n        index: context.getAttribLocation(program, \"a_position\"), // Location of position attributes. @no-wrap\n        size: 2, // 2 components (triangles) per iteration.\n        type: context.FLOAT, // Data expected as 32-bit floats.\n        normalize: false, // Don't normalise data.\n        stride: 0, // 0 = move forward size * sizeof(type) each iteration to get the next position @no-wrap\n        offset: 0 // Start at beginning of buffer\n    }\n\n    const positionBuffer = context.createBuffer()\n    context.bindBuffer(context.ARRAY_BUFFER, positionBuffer)\n\n    // triangle positions for drawing entire grid\n    const positions = [- 1, 1, 1, 1, 1, - 1, 1, - 1, - 1, - 1, - 1, 1]\n    context.bufferData(\n        context.ARRAY_BUFFER,\n        new Float32Array(positions),\n        context.STATIC_DRAW\n    )\n\n    context.clearColor(0, 0, 0, 0)\n    context.clear(context.COLOR_BUFFER_BIT)\n\n    context.useProgram(program)\n\n    context.enableVertexAttribArray(vertexData.index)\n\n    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    const { index, size, type, normalize, stride, offset } = vertexData\n    context.vertexAttribPointer(index, size, type, normalize, stride, offset)\n\n    return { canvas, context, program }\n}\n\n/**\n *\n * @param {BlurridMetadata} metadata\n * @returns {{canvas:HTMLCanvasElement, context:CanvasRenderingContext2D}}\n */\nconst getCanvas2D = metadata => {\n    //\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = metadata.image.width\n    canvas.height = metadata.image.height\n\n    //\n    const context = /** @type {CanvasRenderingContext2D} */\n        (canvas.getContext(\"2d\"))\n\n    return { canvas, context }\n}\n\n/**\n *\n * @param {WebGLRenderingContext} context\n * @param {{vertex:WebGLShader, fragment:WebGLShader}} shaders\n * @returns {WebGLProgram}\n */\nconst getProgram = (context, shaders) => {\n    const program = /** @type {WebGLProgram} */ (context.createProgram())\n\n    context.attachShader(program, shaders.vertex)\n    context.attachShader(program, shaders.fragment)\n    context.linkProgram(program)\n\n    if (!context.getProgramParameter(program, context.LINK_STATUS)) {\n        console.warn(context.getProgramInfoLog(program))\n        context.deleteProgram(program)\n    }\n\n    return program\n}\n\n/**\n * @param {WebGLRenderingContext} context\n * @param {number} type\n * @param {string} source\n * @param {Object.<string,number>} [view={}]\n * @returns {WebGLShader}\n */\nconst getShader = (context, type, source, view = {}) => {\n    for (const key in view) {\n        const regex = new RegExp(`{{${key}}}`, \"g\")\n        source = source.replaceAll(regex, `${view[key]}`)\n    }\n\n    const shader = /** @type {WebGLShader} */ (context.createShader(type))\n\n    context.shaderSource(shader, source)\n    context.compileShader(shader)\n\n    if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {\n        console.warn(context.getShaderInfoLog(shader))\n        context.deleteShader(shader)\n    }\n\n    return shader\n}\n\n// @@exports\nexport { getCanvasWebGL, getCanvas2D }\n","attribute vec4 a_position;\n\nvoid main() {\n    gl_Position = a_position;\n}\n","precision mediump float;\n\nuniform vec4 u_color;\nuniform float u_image_width;\nuniform float u_image_height;\n\nuniform float u_lumaDct[{{SAMPLE_NORMALIZED_TOTAL}}];\nuniform float u_chromaBlueDct[{{SAMPLE_NORMALIZED_TOTAL}}];\nuniform float u_chromaRedDct[{{SAMPLE_NORMALIZED_TOTAL}}];\n\n\nfloat kFactor(int x) {\n    if (x == 0) { return 0.7071; }\n    else { return 1.0; }\n}\n\nfloat decode1D(float array1D[{{SAMPLE_MAX}}], float point, int samples) {\n    float float_samples = float(samples);\n\n    float result = 0.0;\n\n    for (int i = 0; i < {{SAMPLE_MAX}}; i ++) {\n        if (float(array1D[i]) == 0.0 || i >= samples) { break; }\n\n        float partial = float(array1D[i]) * cos(\n            ((2.0 * point + 1.0) * 3.14 * float(i)) / (2.0 * float_samples)\n        );\n\n        partial *= kFactor(i);\n        result += partial;\n    }\n\n    result *= sqrt(2.0 / float_samples);\n\n    return result;\n}\n\nfloat decode2D(float array2D[{{SAMPLE_NORMALIZED_TOTAL}}], vec2 uv) {\n    float row[{{SAMPLE_MAX}}];\n\n    float x = uv.x * {{SAMPLE_WIDTH}}.0;\n    float y = (1.0 - uv.y) * {{SAMPLE_HEIGHT}}.0;\n\n    for (int i = 0; i < {{SAMPLE_MAX}}; i ++) {\n        float column[{{SAMPLE_MAX}}];\n        for (int j = 0; j < {{SAMPLE_MAX}}; j ++) {\n            column[j] = array2D[i * {{SAMPLE_MAX}} + j];\n        }\n        row[i] = decode1D(column, y, {{SAMPLE_HEIGHT}});\n    }\n\n    float result = decode1D(row, x, {{SAMPLE_WIDTH}});\n\n    return result;\n}\n\nvec4 yCbCrToRgb(float luma, float chromaBlue, float chromaRed) {\n    //\n    float red = luma + 1.40 * (chromaRed - 128.0);\n    float green = luma - 0.34 * (chromaBlue - 128.0) - 0.71 * (chromaRed - 128.0);\n    float blue = luma + 1.77 * (chromaBlue - 128.0);\n\n    //\n    red = floor(clamp(red, 0.0, 255.0) + 0.5) / 255.0;\n    green = floor(clamp(green, 0.0, 255.0) + 0.5) / 255.0;\n    blue = floor(clamp(blue, 0.0, 255.0) + 0.5) / 255.0;\n\n    return vec4(red, green, blue, 1.0);\n}\n\nvoid main() {\n    //\n    vec2 uv = gl_FragCoord.xy;\n    uv.x /= u_image_width;\n    uv.y /= u_image_height;\n\n    //\n    gl_FragColor = yCbCrToRgb(\n        decode2D(u_lumaDct, uv),\n        decode2D(u_chromaBlueDct, uv),\n        decode2D(u_chromaRedDct, uv)\n    );\n}\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Methods for decoding dct to dataUrl, and for upsizing decoded images.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\nimport { getCanvasWebGL, getCanvas2D } from \"./canvas.js\"\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { BlurridDecoder, BlurridMetadata } from \"../dct/index.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n/**\n *\n * @param {BlurridDecoder} decoder\n * @returns {string}\n */\nconst getDataUrl = decoder => {\n    const { metadata, coefficients } = decoder\n    const { canvas, context, program } = getCanvasWebGL(metadata)\n\n    /** @type {Object.<string,{type:string, data:any}>} */\n    const uniforms = {\n        \"u_color\": { type: \"uniform4fv\", data: [1, 0, 0, 1] },\n        \"u_image_width\": { type: \"uniform1f\", data: metadata.image.width },\n        \"u_image_height\": { type: \"uniform1f\", data: metadata.image.height },\n        \"u_lumaDct\": {\n            type: \"uniform1fv\",\n            data: normalizeDctSamples(coefficients.luma, metadata)\n        },\n        \"u_chromaBlueDct\": {\n            type: \"uniform1fv\",\n            data: normalizeDctSamples(coefficients.chromaBlue, metadata)\n        },\n        \"u_chromaRedDct\": {\n            type: \"uniform1fv\",\n            data: normalizeDctSamples(coefficients.chromaRed, metadata)\n        }\n    }\n\n    for (const key in uniforms) {\n        const location = context.getUniformLocation(program, key)\n        // @ts-expect-error - String *can* index WebGLUniformLocation\n        context[uniforms[key].type](location, uniforms[key].data)\n    }\n\n    const drawData = {\n        primitiveType: context.TRIANGLES,\n        offset: 0,\n        count: 6\n    }\n\n    const { primitiveType, offset, count } = drawData\n    context.drawArrays(primitiveType, offset, count)\n\n    return canvas.toDataURL()\n}\n\n/**\n *\n * @param {number[][]} array2D\n * @param {BlurridMetadata} metadata\n * @returns\n */\nconst normalizeDctSamples = (array2D, metadata) => {\n    const length = /** @type {number} */ (metadata.sample.max)\n\n    return Array.from({ length: length ** 2 }, (_, index) => {\n        return array2D.flatMap(array1D => {\n            return Array.from({ length }, (_, index) => array1D[index] || 0)\n        })[index] || 0\n    })\n}\n\n/**\n *\n * @param {object} target\n * @param {HTMLCanvasElement} target.canvas\n * @param {CanvasRenderingContext2D} target.context\n * @param {ImageData} imageData\n * @param {BlurridDecoder} decoder\n * @returns {Promise.<string>}\n */\nconst upsizeImageData = (target, imageData, decoder) => {\n    return new Promise(resolve => {\n        const image = document.createElement(\"img\")\n\n        const listener = () => {\n            const { width, height } = target.canvas\n            target.context.drawImage(image, 0, 0, width, height)\n\n            image.removeEventListener(\"load\", listener)\n            image.remove()\n\n            resolve(target.canvas.toDataURL())\n        }\n\n        image.addEventListener(\"load\", listener)\n\n        decoder.metadata.resize(imageData.width)\n        const { canvas, context } = getCanvas2D(decoder.metadata)\n        context.putImageData(imageData, 0, 0)\n        image.src = canvas.toDataURL()\n    })\n}\n\n// @@exports\nexport { getDataUrl, upsizeImageData }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Wrapper around worker to allow for instantiating workers on the fly.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n *\n * @returns {Worker}\n */\nconst getBlurridWorker = () => {\n    return new Worker(\n        new URL(\"./worker.js\", import.meta.url),\n        { type: \"module\" }\n    )\n}\n\n// @@exports\nexport { getBlurridWorker }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file BlurridImage web component, including worker fallback.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-package\nimport {\n    getDataUrl,\n    getCanvas2D,\n    upsizeImageData,\n    getBlurridWorker\n} from \"../shader/index.js\"\n\n// @@imports-module\nimport { BlurridImage } from \"./BlurridImage.js\"\n\n// @@imports-utils\nimport { WorkerManager } from \"../utils/index.js\"\n\n// @@body\nlet /** @type {WorkerManager|undefined} */ blurridWorkerManager\n\nclass BlurridImageWorker extends BlurridImage {\n    #workerStart = parseInt(this.dataset.workerStart || \"16\")\n    #workerSteps = parseInt(this.dataset.workerSteps || \"2\")\n\n    constructor() { super() }\n\n    blur() {\n        const maxSamples = this.decoder.metadata.sample.max\n        if (!window.WebGLRenderingContext || maxSamples > 16) {\n            if (!blurridWorkerManager) {\n                blurridWorkerManager = new WorkerManager(getBlurridWorker)\n            }\n\n            const target = getCanvas2D(this.decoder.metadata)\n            this.stepWorker(target.canvas.toDataURL(), target)\n        }\n        else { this.src = getDataUrl(this.decoder) }\n    }\n\n    /**\n     *\n     * @param {string} dataUrl\n     * @param {object} target\n     * @param {HTMLCanvasElement} target.canvas\n     * @param {CanvasRenderingContext2D} target.context\n     * @param {number} [width]\n     */\n    stepWorker(dataUrl, target, width) {\n        this.src = dataUrl\n\n        width ??= this.#workerStart\n        if (width < this.#workerStart * 2 ** this.#workerSteps) {\n            const message = {\n                serializedDct: this.decoder.serializedDct,\n                width: width * 2\n            }\n            blurridWorkerManager?.enqueue(message, event => {\n                const { imageData, imageData: { width } } = event.data\n                upsizeImageData(target, imageData, this.decoder)\n                    .then(dataUrl => {\n                        this.stepWorker(dataUrl, target, width)\n                    })\n            })\n        }\n    }\n}\n\n// @@exports\nexport { BlurridImageWorker }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Import required lucide icons.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-dependencies\nimport { createIcons, Info } from \"lucide\"\n\n// @@body\ncreateIcons({\n    icons: {\n        Info\n    }\n})\n\n// @@no-exports\n"],"names":["$6214776a3babbdfa$var$blurridWorkerManager","createIcons","$cw5NC$createIcons","Info","$cw5NC$Info","$parcel$interopDefault","a","__esModule","default","$365a44e770a0b11c$export$39785c5d1570d2b1","Error","constructor","options","message","key","name","detail","$365a44e770a0b11c$export$83736ebe6a735486","$365a44e770a0b11c$export$c80826d3392ea781","string","modifiers","tabs","tabSize","compoundModifier","modifier","reset","$365a44e770a0b11c$export$e1ac8087f5f1bfe7","decorations","indent","repeat","color","colorModifier","fgColors","black","red","green","yellow","blue","magenta","cyan","white","gray","bright","dim","underline","blink","reverse","hidden","$931f6948e16b2f88$export$c28500e84d42e56e","expandedSample","channelData","map","channel","$931f6948e16b2f88$var$collapseChannel","length1","length","sampleData","Array","from","fill","i","entries","j","pixel","channel2D","width","channel1D","channelRow","push","$04f5c56647ae8c40$export$a343f46e34a234f1","image","sample","max","Math","height","resize","round","$025fa45280fd44fb$export$4f347c1cf22bbd8","buffer","readPointer","lastReadSize","writePointer","lastWriteSize","size","floor","ArrayBuffer","write","int","bitLength","offset","signed","writeable","append","isWriteable","NaN","writeAbsolute","value","writeRelative","relativeSize","abs","writeString","char","charCodeAt","read","readable","isReadable","readAbsolute","readRelative","sign","readString","lengthSize","String","fromCharCode","copy","target","targetStart","sourceStart","sourceEnd","sourceBits","targetBits","ceil","toString","pointer","uint24","view","Uint8Array","byteLength","byte","uint24ToB64","tracer","uint32","bitsRemaining","Number","isInteger","subBit","getView","getUint8","uint8","index","bit","setUint8","startByte","DataView","match","b64ToUint24","padEnd","split","uint6","dict","indexOf","$86e52ea92617c364$export$bcff6015853c67ce","queue","workers","Map","instantiateWorker","limit","callback","addWorker","worker","set","postWorker","onmessage","event","dequeue","postMessage","enqueue","existingWorker","timeLastActive","shift","Date","now","setTimeout","get","terminate","delete","$b25947ab9039cbe8$export$15fcc258e19c8efc","luma","chromaBlue","chromaRed","total","subsampling","groups","parseInt","subsample","$95222a7a04e259da$var$buildDctArray2D","array2D","x","y","sum","$05e2715665d4e47d$var$clamp","number","minimum","maximum","isInt","min","$05e2715665d4e47d$export$f8d5c49fa675945f","$05e2715665d4e47d$export$8bc460b4baf863e7","yCbCrArray","alpha","rgbaArray","$0525f6702f01f430$export$b24f58bb0238ca0c","array3D","metadata","lumaDct","chromaBlueDct","chromaRedDct","emptyChannel","channels","lumaChannel","chromaBlueChannel","chromaRedChannel","point","$0525f6702f01f430$var$decodePixelArray2D","dctRow","dctColumn","$0525f6702f01f430$var$decodePixelArray1D","$0525f6702f01f430$var$fastCos","radians","PI","array1D","pointX","result","partial","SQRT1_2","sqrt","$7285f96793324acb$export$a17c6f6fb2637705","serializedDct","coefficients","deserializeMetadata","deserializeCoefficients","toImageData","deserializeSubsampling","dctBuilder","next","coefficient","isNaN","subsampleSelector","builders","iteration","done","$7396a80ccdef2400$exports","$f8fa4ba9caed0201$exports","$b4fab70876281105$export$10c7fe55c4ed3d74","canvas","document","createElement","context","getContext","shaders","vertex","$b4fab70876281105$var$getShader","VERTEX_SHADER","fragment","FRAGMENT_SHADER","SAMPLE_WIDTH","SAMPLE_HEIGHT","SAMPLE_MAX","SAMPLE_NORMALIZED_TOTAL","program","$b4fab70876281105$var$getProgram","vertexData","getAttribLocation","type","FLOAT","normalize","stride","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","clearColor","clear","COLOR_BUFFER_BIT","useProgram","enableVertexAttribArray","vertexAttribPointer","$b4fab70876281105$export$7bfb6a10627b78e8","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","console","warn","getProgramInfoLog","deleteProgram","source","regex","RegExp","replaceAll","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","$dad962c3e2511d5c$export$4631f9310db9e583","decoder","uniforms","data","$dad962c3e2511d5c$var$normalizeDctSamples","location","getUniformLocation","primitiveType","count","TRIANGLES","drawArrays","toDataURL","_","flatMap","$dad962c3e2511d5c$export$35004646828cefa0","imageData","Promise","resolve","listener","drawImage","removeEventListener","remove","addEventListener","putImageData","src","$11e58dde46b2e744$export$a34c9cac3423e245","Worker","URL","url","$1b148c2943747f56$export$e4065b753f58196c","HTMLImageElement","dataset","blurrid","blur","loading","loadOnClick","loadOnIntersection","loadImage","blurWidth","maxSamples","window","WebGLRenderingContext","attribute","attributes","reservedAttributes","includes","setAttribute","getBoundingClientRect","style","keyframes","opacity","easing","duration","clone","cloneNode","position","before","animate","direction","replaceWith","srcset","observer","IntersectionObserver","entry","isIntersecting","disconnect","threshold","observe","slotSize","sizes","regexps","sizesFallback","matchAll","query","unit","matchMedia","matches","slotWidth","innerWidth","srcsetWidth","$6214776a3babbdfa$export$a549820b6a231fbc","workerStart","workerSteps","stepWorker","dataUrl","then","icons","customElements","define","extends","BlurridImageWorker","BlurridImage","getDataUrl","BlurridDecoder","getCanvas2D","#blurWidth","undefined","#reservedAttributes","DecoratedError","expandSample","expandChannel","collapseSample","collapseChannel","decorateFg","decorate","cliModifiers","decorateBg","bgColors","padEndDecorated","maxLength","fillString","decoratorLength","join","padStartDecorated","padStart","toCamelCase","kebabCaseString","isUpper","isSpaced","reduce","acc","cur","isCapital","nextChar","toUpperCase","toLowerCase","toKebabCase","camelCaseString","isNewWord","BlurridMetadata","buildDctArray3D","yCbCrArrayToRgbaArray","decodePixelArray3D","BUFFER_LOCATIONS","SubsampleSelector","BitBuffer","#deserializeMetadata","METADATA","#deserializeSubsampling","SUBSAMPLING","#deserializeCoefficients","COEFFICIENTS","ASSUMED_COEFFICIENT_SIZE","#dctBuilder","buildDctArray2D","targetSize","#writeable","#write","#readable","#read","#getView","#b64ToUint24","#uint24ToB64","#bitLength","#dict","WorkerManager","#dequeue","clamp","rgbToYCbCr","rgbaBufferToYCbCrArray","rgbaBuffer","yCbCrToRgb","decodePixelArray2D","decodePixelArray1D","fastCos","consumeDctArray3D","encodePixelArray3D","BlurridEncoder","ratio","samples","secondarySamples","sampleWidth","sampleHeight","serializeMetadata","serializeSubsampling","serializeCoefficients","#serializeMetadata","#serializeSubsampling","#serializeCoefficients","dctConsumer","written","#dctConsumer","lumaArray2D","chromaBlueArray2D","chromaRedArray2D","consumers","consumeDctArray2D","coefficientRow","encodePixelArray2D","primaryEncodedArray2D","encodePixelArray1D","secondaryEncodedArray2D","column","cos","vertexSource","fragmentSource","getCanvasWebGL","getShader","getProgram","positions","module","exports","normalizeDctSamples","drawData","upsizeImageData","getBlurridWorker","import","meta","blurridWorkerManager"],"version":3,"file":"index.6581faf8.js.map"}