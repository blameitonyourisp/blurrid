{"mappings":"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","sources":["<anon>","src/package/shader/worker.js","src/package/dct/BlurridDecoder.js","src/package/dct/array-conversions.js","src/package/utils/decorate-cli.js","src/package/dct/BlurridMetadata.js","src/package/dct/builders.js","src/package/dct/SubsampleSelector.js","src/package/utils/index.js","src/package/utils/BitBuffer.js","src/package/utils/WorkerManager.js","src/package/dct/colorspace-conversions.js","src/package/dct/decode.js","src/package/dct/serialize.js"],"sourcesContent":["(function () {\nvar $9840497c57b205ab$exports = {};\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Worker backup for generating image blur placeholders without gpu.\n * @author James Reid\n */ // @ts-check\n// @@imports-package\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Wrapper class around blurrid dct decoding functions.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Array dimension conversions for jpg dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@imports-utils\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Functions for decorating cli strings.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n * Custom error which renders an error in a uniform way, taking an options\n * object with reserved name and message fields, and then any other fields\n * relevant to the error, and rendering them with indentation.\n */ class $ea1325424b5d060b$export$39785c5d1570d2b1 extends Error {\n    /**\n   * Build new error based on supplied options object which may set the custom\n   * name of the error, the top level message of the error, and then any\n   * number of other custom fields.\n   *\n   * @param {Object.<string,string|number|boolean>} options - Options object\n   *      containing any string keys, and string, number or boolean values.\n   */ constructor(options){\n        super();\n        let message = \"\";\n        // Parse all properties in options argument; if key is name, use value\n        // to set the custom name of the error, if key is message, append value\n        // top of error message, otherwise render a grey, tabbed key-value\n        // pair to the end of the message string.\n        for(const key in options)switch(key){\n            case \"name\":\n                this.name = /** @type {string} */ options[key];\n                break;\n            case \"message\":\n                message = `${options[key]}\\n${message}`;\n                break;\n            default:\n                {\n                    const detail = `${key}: ${options[key]}`;\n                    message = `${message}${$ea1325424b5d060b$export$83736ebe6a735486(detail, \"gray\", 1)}\\n`;\n                }\n        }\n        // Set error message which will be displayed.\n        this.message = message || \"\";\n    }\n}\n/**\n * Decorate a string with control characters for changing cli string colors and\n * text decoration. Adds supplied list of modifiers for the string, then uses\n * reset character to set text back to default.\n *\n * @summary Return original string decorated with control characters.\n * @param {string} string - String to be decorated.\n * @param {object} options - Options object.\n * @param {string[]} [options.modifiers] - String array of modifiers/control\n *      characters to apply input string.\n * @param {number} [options.tabs] - Number of tab indents to include on string.\n * @param {number} [options.tabSize] - Number of spaces for each tab.\n * @returns {string} Original string decorated with control characters.\n */ const $ea1325424b5d060b$export$c80826d3392ea781 = (string, { modifiers: modifiers = [], tabs: tabs = 0, tabSize: tabSize = 4 } = {})=>{\n    // Make compound modifier string form array of supplied control characters.\n    let compoundModifier = \"\";\n    for (const modifier of modifiers)compoundModifier = `${compoundModifier}${modifier}`;\n    // Wrap input string with control characters and reset character.\n    const reset = $ea1325424b5d060b$export$e1ac8087f5f1bfe7.decorations.reset;\n    const indent = \" \".repeat(tabs * tabSize);\n    return `${compoundModifier}${indent}${string}${reset}`;\n};\n/**\n * Wrapper around decorate function to decorate a string with a foreground\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a foreground colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired foreground colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */ const $ea1325424b5d060b$export$83736ebe6a735486 = (string, color, tabs = 0)=>{\n    const colorModifier = $ea1325424b5d060b$export$e1ac8087f5f1bfe7.fgColors[color];\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier ? $ea1325424b5d060b$export$c80826d3392ea781(string, {\n        modifiers: [\n            colorModifier\n        ],\n        tabs: tabs\n    }) : $ea1325424b5d060b$export$c80826d3392ea781(string, {\n        tabs: tabs\n    });\n};\n/**\n * Wrapper around decorate function to decorate a string with a background\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a background colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired background colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */ const $ea1325424b5d060b$export$452607015d3d1c9f = (string, color, tabs = 0)=>{\n    const colorModifier = $ea1325424b5d060b$export$e1ac8087f5f1bfe7.bgColors[color];\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier ? $ea1325424b5d060b$export$c80826d3392ea781(string, {\n        modifiers: [\n            colorModifier\n        ],\n        tabs: tabs\n    }) : $ea1325424b5d060b$export$c80826d3392ea781(string, {\n        tabs: tabs\n    });\n};\n/**\n * Wrapper around String.prototype.padEnd method, which pads end of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad end of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padEnd method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */ const $ea1325424b5d060b$export$30fcb72c6bf87eba = (string, maxLength, fillString)=>{\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0;\n    return string.padEnd(maxLength + decoratorLength, fillString);\n};\n/**\n * Wrapper around String.prototype.padStart method, which pads start of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad start of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padStart method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */ const $ea1325424b5d060b$export$adfb6bac270c262a = (string, maxLength, fillString)=>{\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0;\n    return string.padStart(maxLength + decoratorLength, fillString);\n};\n// Object of cli control strings for decorations etc.\nconst $ea1325424b5d060b$export$e1ac8087f5f1bfe7 = {\n    // Foreground modifiers.\n    /** @type {Object.<string,string>} */ fgColors: {\n        black: \"\\x1b[30m\",\n        red: \"\\x1b[31m\",\n        green: \"\\x1b[32m\",\n        yellow: \"\\x1b[33m\",\n        blue: \"\\x1b[34m\",\n        magenta: \"\\x1b[35m\",\n        cyan: \"\\x1b[36m\",\n        white: \"\\x1b[37m\",\n        gray: \"\\x1b[90m\"\n    },\n    // Background modifiers.\n    /** @type {Object.<string,string>} */ bgColors: {\n        black: \"\\x1b[40m\",\n        red: \"\\x1b[41m\",\n        green: \"\\x1b[42m\",\n        yellow: \"\\x1b[43m\",\n        blue: \"\\x1b[44m\",\n        magenta: \"\\x1b[45m\",\n        cyan: \"\\x1b[46m\",\n        white: \"\\x1b[47m\",\n        gray: \"\\x1b[100m\"\n    },\n    // Decoration modifiers.\n    /** @type {Object.<string,string>} */ decorations: {\n        reset: \"\\x1b[0m\",\n        bright: \"\\x1b[1m\",\n        dim: \"\\x1b[2m\",\n        underline: \"\\x1b[4m\",\n        blink: \"\\x1b[5m\",\n        reverse: \"\\x1b[7m\",\n        hidden: \"\\x1b[8m\"\n    }\n};\n/**\n * Convert kebab-case string to camelCase string, removing all hyphens in input\n * string, and capitalising the first character following each hyphen. Options\n * available for generating UpperCamelCase strings, and spaced strings too.\n *\n * @summary Convert kebab-case string to camelCase string.\n * @param {string} kebabCaseString - Input kebab-case string.\n * @param {boolean} isUpper - Should return string be in UpperCamelCase?\n * @param {boolean} isSpaced - Should return string replace hyphens with\n *      whitespace characters?\n * @returns {string} camelCase string version of input.\n */ const $ea1325424b5d060b$export$86f54f62aa7a7514 = (kebabCaseString, isUpper = false, isSpaced = false)=>{\n    // Reduce split input string with starting value object containing an empty\n    // string and flag set to isUpper for if next character should be capital.\n    return kebabCaseString.split(\"\").reduce((acc, cur)=>{\n        // Ignore hyphens, or replace with spaces as required.\n        if (cur === \"-\") return isSpaced ? {\n            string: `${acc.string} `,\n            isCapital: true\n        } : {\n            ...acc,\n            isCapital: true\n        };\n        // Concatenate string with next character set to uppercase if required.\n        const nextChar = acc.isCapital ? cur.toUpperCase() : cur.toLowerCase();\n        return {\n            string: `${acc.string}${nextChar}`,\n            isCapital: false\n        };\n    }, {\n        string: \"\",\n        isCapital: isUpper\n    }).string;\n};\n/**\n * Convert camelCaseString to kebab-case-string, adding hyphens between words.\n * If input string includes spaces (for example the verbatim title of a\n * markdown documentation file), replace with hyphens - this is good for\n * converting a title string to a valid kebab-case-filename. Option also\n * available for generating Upper-Kebab-Case strings.\n *\n * @summary Convert camelCaseString to kebab-case-string.\n * @param {string} camelCaseString - Input camelCaseString.\n * @param {boolean} isUpper - Should return string be in Upper-Kebab-Case?\n * @returns {string} kebab-case-string version of input.\n */ const $ea1325424b5d060b$export$73bda83cddbc7187 = (camelCaseString, isUpper = false)=>{\n    // Reduce split input string with starting value object containing an empty\n    // string and a new word flag set to true.\n    return camelCaseString.split(\"\").reduce((acc, cur)=>{\n        // Ignore spaces in the input string, but set new word flag to true.\n        if (cur === \" \") return {\n            ...acc,\n            isNewWord: true\n        };\n        else if (acc.isNewWord || cur.match(/[A-Z]/)) {\n            const nextChar = isUpper ? cur.toUpperCase() : cur.toLowerCase();\n            return acc.string ? {\n                string: `${acc.string}-${nextChar}`,\n                isNewWord: false\n            } : {\n                string: `${nextChar}`,\n                isNewWord: false\n            };\n        }\n        // Otherwise, append current letter in lowercase.\n        const nextChar = cur.toLowerCase();\n        return {\n            string: `${acc.string}${nextChar}`,\n            isNewWord: false\n        };\n    }, {\n        string: \"\",\n        isNewWord: true\n    }).string;\n};\n\n\n// @@body\n/**\n *\n * @param {number[]} sampleData\n * @param {number} width\n * @param {number} channels\n * @returns {number[][][]}\n */ const $8884bdd64f3f6eda$export$b0d6d19929940a93 = (sampleData, width, channels = 3)=>{\n    if (sampleData.length % channels) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n        name: \"ChannelError\",\n        message: \"Data length is not a multiple of requested channel count\",\n        \"data-length\": sampleData.length,\n        \"channels-requested\": channels\n    });\n    /** @type {number[][]} */ const channelData = Array.from(Array.from({\n        length: channels\n    }), ()=>[]);\n    for (const [i, pixel] of sampleData.entries())channelData[i % channels].push(pixel);\n    return channelData.map((channel)=>$8884bdd64f3f6eda$var$expandChannel(channel, width));\n};\n/**\n *\n * @param {number[]} channel1D\n * @param {number} width\n * @returns {number[][]}\n */ const $8884bdd64f3f6eda$var$expandChannel = (channel1D, width)=>{\n    if (channel1D.length % width) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n        name: \"ChannelError\",\n        message: \"Channel length is not a multiple of row width\",\n        \"channel-length\": channel1D.length,\n        \"row-width\": width\n    });\n    /** @type {number[][]} */ const channel2D = Array.from(Array.from({\n        length: channel1D.length / width\n    }), ()=>[]);\n    for (const [i, pixel] of channel1D.entries())channel2D[Math.floor(i / width)].push(pixel);\n    return channel2D;\n};\n/**\n *\n * @param {number[][][]} expandedSample\n * @returns {number[]}\n */ const $8884bdd64f3f6eda$export$c28500e84d42e56e = (expandedSample)=>{\n    const channelData = expandedSample.map((channel)=>$8884bdd64f3f6eda$var$collapseChannel(channel));\n    const length1 = channelData[0].length;\n    const sampleData = Array.from({\n        length: channelData.length * length1\n    }).fill(0);\n    for (const [i, channel] of channelData.entries()){\n        if (channel.length !== length1) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"ChannelError\",\n            message: \"Sample channels not of same length\",\n            \"default-length\": length1,\n            \"channel-length\": channel.length\n        });\n        for (const [j, pixel] of channel.entries())sampleData[channelData.length * j + i] = pixel;\n    }\n    return sampleData;\n};\n/**\n *\n * @param {number[][]} channel2D\n * @returns {number[]}\n */ const $8884bdd64f3f6eda$var$collapseChannel = (channel2D)=>{\n    const width = channel2D[0].length;\n    const channel1D = [];\n    for (const channelRow of channel2D){\n        if (channelRow.length !== width) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"ChannelError\",\n            message: \"Channel row width does not match sample width\",\n            \"sample-width\": length,\n            \"row-width\": channelRow.length\n        });\n        channel1D.push(...channelRow);\n    }\n    return channel1D;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Class for building and accessing dct metadata.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\nclass $9499b67a6b43b7b7$export$a343f46e34a234f1 {\n    #image;\n    #sample;\n    /**\n   *\n   * @param {object} obj\n   * @param {object} obj.image\n   * @param {number} obj.image.width\n   * @param {number} obj.image.height\n   * @param {object} obj.sample\n   * @param {number} obj.sample.width\n   * @param {number} obj.sample.height\n   */ constructor({ image: image, sample: sample }){\n        this.#image = image;\n        this.#sample = {\n            ...sample,\n            max: Math.max(sample.width, sample.height)\n        };\n    }\n    /**\n   *\n   * @param {number} width\n   */ resize(width) {\n        this.#image.height = Math.round(this.#image.height * width / this.#image.width);\n        this.#image.width = width;\n    }\n    get image() {\n        return this.#image;\n    }\n    get sample() {\n        return this.#sample;\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Generators for building arrays of dct coefficients.\n * @author James Reid\n */ // @ts-check\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */ // Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Class for processing subsample strings.\n * @author James Reid\n */ // @ts-check\n// @@imports-utils\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Export utility methods.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@no-body\n// @@exports\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Buffer class allowing control at bit level rather than byte level.\n * @author James Reid\n */ // @ts-check\n// @@imports-module\n\n// @@body\n/**\n * Buffer class allowing control over an appropriately sized array buffer at the\n * bit level rather than at the byte level.\n */ class $88bbf908b96b83e8$export$4f347c1cf22bbd8 {\n    #buffer;\n    #readPointer;\n    #lastReadSize;\n    #writePointer;\n    #lastWriteSize;\n    /**\n   * Configure internal buffer property and required pointers.\n   *\n   * @param {object} obj - Configuration object argument.\n   * @param {number} [obj.length] - Maximum character length of buffer when\n   *      converted to url-safe base64 string.\n   * @param {number} [obj.size] - Size of BitBuffer in *bytes*. Defaults to\n   *      maximum allowable size as specified by the character length value.\n   * @param {ArrayBuffer} [obj.buffer] - Internal array buffer.\n   */ constructor({ length: length = 16, size: size = Math.floor(length * 6 / 8), buffer: buffer = new ArrayBuffer(size) } = {}){\n        // Assign internal array buffer for implementation of BitBuffer.\n        this.#buffer = buffer;\n        // Assign internal read pointers.\n        this.#readPointer = 0;\n        this.#lastReadSize = 0;\n        // Assign internal write pointers.\n        this.#writePointer = 0;\n        this.#lastWriteSize = 0;\n    }\n    /**\n   * Write an integer directly to internal buffer, updating write pointers to\n   * the end of the written data.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.size] - Size of buffer segment to write in bits.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ write(int, { size: size = $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(int), offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable().append(int, {\n            size: size,\n            offset: offset,\n            signed: signed\n        });\n        if (!writeable.isWriteable) return NaN;\n        return this.#write(int, {\n            size: size,\n            offset: offset,\n            signed: signed\n        });\n    }\n    /**\n   * Write an integer to internal buffer with an absolute size declaration to\n   * indicate how many bits are written (i.e. 5 additional bits written\n   * indicating length of written data between 0 and 32 bits). Update write\n   * pointers to the end of the written data.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ writeAbsolute(int, { offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // Size declaration data with the size of buffer segment it will occupy.\n        const resize = {\n            value: $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(int),\n            size: 5\n        };\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable().append(resize.value, {\n            ...resize,\n            offset: offset\n        }).append(int, {\n            signed: signed\n        });\n        if (!writeable.isWriteable) return NaN;\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, {\n            ...resize,\n            offset: offset\n        });\n        const uint32 = this.#write(int, {\n            signed: signed\n        });\n        return uint32;\n    }\n    /**\n   * Write an integer to internal buffer with a relative size declaration to\n   * indicate how many bits are written (i.e. 1 \"sign\" bit to indicate if more\n   * or less bits than the previous write call are being written, and n \"0\"\n   * bits where n is the relative size between the previous and next write\n   * call sizes). Update write pointers to the end of the written data.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ writeRelative(int, { offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // Write relative method relies on the first bit of the written integer\n        // being \"1\", and therefore cannot write integer \"0\".\n        if (int === 0) int = 1;\n        // Size declaration data with the size of buffer segment it will occupy.\n        const relativeSize = $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(int) - this.#lastWriteSize;\n        const resize = {\n            // If increasing size, write a 1 bit shifted by the amount of bits\n            // the data is bigger by, otherwise write a 0. Preserve required\n            // bit length of size declaration using size property.\n            value: relativeSize > 0 ? 1 << relativeSize >>> 0 : 0,\n            size: Math.abs(relativeSize) + 1\n        };\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable().append(resize.value, {\n            ...resize,\n            offset: offset\n        }).append(int, {\n            signed: signed\n        });\n        if (!writeable.isWriteable) return NaN;\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, {\n            ...resize,\n            offset: offset\n        });\n        const uint32 = this.#write(int, {\n            signed: signed\n        });\n        return uint32;\n    }\n    /**\n   * Write a string of arbitrary length to the internal buffer.\n   *\n   * @param {string} string - String to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @returns {string} String written to buffer.\n   */ writeString(string, { offset: offset = this.#writePointer } = {}) {\n        // Size declaration data for bit length of length of string declaration.\n        const resize = {\n            value: $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(string.length),\n            size: 5\n        };\n        // If all characters are not writeable due to insufficient bits\n        // remaining etc., then return empty string.\n        let writeable = this.#writeable().append(resize.value, {\n            ...resize\n        }).append(string.length);\n        for(let i = 0; i < string.length; i++)writeable = writeable.append(0, {\n            size: 8\n        });\n        if (!writeable.isWriteable) return \"\";\n        // Write string length declaration and string to buffer.\n        this.#write(resize.value, {\n            ...resize,\n            offset: offset\n        });\n        this.#write(string.length);\n        for (const char of string)this.#write(char.charCodeAt(0), {\n            size: 8\n        });\n        return string;\n    }\n    /**\n   * Read an integer directly from internal buffer, updating read pointers to\n   * the end of the read data.\n   *\n   * @param {number} size - Size of buffer segment to read.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ read(size, { offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        // If all values are not readable due to insufficient bits remaining\n        // etc., then return no number.\n        const readable = this.#readable().append(size, {\n            offset: offset,\n            signed: signed\n        });\n        if (!readable.isReadable) return NaN;\n        return this.#read(size, {\n            offset: offset,\n            signed: signed\n        });\n    }\n    /**\n   * Read an integer from internal buffer, determining bit size of segment\n   * by reading an absolute size declaration from the buffer indicating how\n   * many bits should be read (i.e. 5 additional bits read before reading\n   * integer to determine bit size of read segment between 0 and 32 bits).\n   * Update read pointers to the end of the read data.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ readAbsolute({ offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer;\n        const lastReadSize = this.#lastReadSize;\n        // Check if sufficient read bits remain to read both the size\n        // declaration and integer.\n        const readable = this.#readable().append(5, {\n            offset: offset\n        });\n        let size = 0;\n        if (readable.isReadable) {\n            size = this.#read(5, {\n                offset: offset\n            });\n            readable.append(size, {\n                signed: signed\n            });\n        }\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer;\n            this.#lastReadSize = lastReadSize;\n            return NaN;\n        }\n        return this.#read(size, {\n            signed: signed\n        });\n    }\n    /**\n   * Read an integer from internal buffer, determining bit size of segment by\n   * reading a relative size declaration from the buffer indicating how many\n   * bit should be read (i.e. 1 \"sign\" bit to indicate if more or less bits\n   * than the previous read call are being read, and n \"0\" bits where n is the\n   * relative size between the previous and next read call sizes). Update read\n   * pointers to the end of the read data.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ readRelative({ offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer;\n        const lastReadSize = this.#lastReadSize;\n        // Get sign of relative size (i.e. are more or less bits to be read than\n        // last read call).\n        let sign = 1;\n        const readable = this.#readable().append(1, {\n            offset: offset\n        });\n        if (readable.isReadable) sign = this.#read(1, {\n            offset: offset\n        }) ? 1 : -1;\n        // Get unsigned read size relative to size of last read call (reads\n        // until first bit of integer to be read, then breaks).\n        let relativeSize = 0;\n        while(readable.append(1).isReadable){\n            if (this.#read(1)) break;\n            relativeSize++;\n        }\n        // Get size of integer to be read from buffer.\n        const size = lastReadSize + sign * relativeSize;\n        readable.append(size, {\n            signed: signed\n        });\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer;\n            this.#lastReadSize = lastReadSize;\n            return NaN;\n        }\n        // Decrement read pointer to account for first bit of integer having\n        // been read above.\n        this.#readPointer--;\n        return this.#read(size, {\n            signed: signed\n        });\n    }\n    /**\n   * Read a string of arbitrary length from the internal buffer.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @returns {string} String read from buffer.\n   */ readString({ offset: offset = this.#readPointer } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer;\n        const lastReadSize = this.#lastReadSize;\n        // Get bit size of string length declaration.\n        const readable = this.#readable().append(5, {\n            offset: offset\n        });\n        let lengthSize = 0;\n        if (readable.isReadable) lengthSize = this.#read(5, {\n            offset: offset\n        });\n        readable.append(lengthSize);\n        // Get string length.\n        let length = 0;\n        if (readable.isReadable) length = this.#read(lengthSize);\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !length) {\n            this.#readPointer = readPointer;\n            this.#lastReadSize = lastReadSize;\n            return \"\";\n        }\n        let string = \"\";\n        for(let i = 0; i < length; i++){\n            // Ensure next byte (8 bit character) is readable.\n            readable.append(8);\n            // Reset pointers and return no number if insufficient remaining\n            // read bits.\n            if (!readable.isReadable) {\n                this.#readPointer = readPointer;\n                this.#lastReadSize = lastReadSize;\n                return \"\";\n            }\n            // Read character from buffer and append to string.\n            string += String.fromCharCode(this.#read(8));\n        }\n        return string;\n    }\n    /**\n   * Copy data from source buffer (current buffer instance) to a target buffer\n   * passed in the arguments. If no target buffer passed, new BitBuffer\n   * instantiated with a length based on number of copied bits. Will update\n   * read/write pointers in both source and target buffers.\n   *\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {BitBuffer} [obj.target] - Target buffer to copy to.\n   * @param {number} [obj.targetStart] - Start bit in target buffer.\n   * @param {number} [obj.sourceStart] - Start bit in source buffer.\n   * @param {number} [obj.sourceEnd] - End bit in source buffer.\n   * @returns {BitBuffer} Target buffer with data copied from source buffer.\n   */ copy({ target: target, targetStart: targetStart = target?.writePointer || 0, sourceStart: sourceStart = 0, sourceEnd: sourceEnd = this.bitLength } = {}) {\n        // Throw error if source start or end bounds are out of buffer range.\n        if (sourceStart < 0 || sourceEnd > this.bitLength) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"BitBufferError\",\n            message: \"Requested bits out of source buffer range\",\n            \"source-start\": sourceStart,\n            \"source-end\": sourceEnd,\n            \"source-bit-length\": this.bitLength\n        });\n        // Get number of source bits, and minimum size of target buffer in bytes\n        // to store the data from the source buffer.\n        const sourceBits = sourceEnd - sourceStart;\n        const targetSize = Math.ceil((sourceBits + targetStart) / 8);\n        // Get available write bits in target buffer, instantiating a BitBuffer\n        // of the correct size if none is passed in arguments.\n        target ??= new $88bbf908b96b83e8$export$4f347c1cf22bbd8({\n            size: targetSize\n        });\n        const targetBits = target.bitLength - targetStart;\n        // Throw error if not sufficient bits remaining in target buffer.\n        if (sourceBits > targetBits) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"BitBufferError\",\n            message: \"Source bits exceed bits available in target buffer\",\n            \"source-bits\": sourceBits,\n            \"target-bits\": targetBits\n        });\n        // Copy data bits from source buffer to target buffer.\n        for(let i = 0; i < sourceBits; i++)target.write(this.#read(1, {\n            offset: sourceStart + i\n        }), {\n            size: 1,\n            offset: targetStart + i\n        });\n        return target;\n    }\n    /**\n   * Convert buffer to serialized string of base-64 url-safe characters.\n   *\n   * @returns {string} Serialized buffer string.\n   */ toString() {\n        // Initialize serialized string and pointers to track string fragments.\n        let string = \"\";\n        let pointer = 0;\n        let uint24 = 0;\n        // Loop over buffer, adding 4 character fragments to serialized string\n        // for every 24 bits consumed from buffer (24-bit blocks consumed in\n        // 3-byte blocks at time).\n        const view = new Uint8Array(this.#buffer);\n        for(let i = 0; i < Math.ceil(this.byteLength / 3) * 3; i++){\n            const byte = view[i] || 0;\n            uint24 = (uint24 | byte << 16 - pointer * 8) >>> 0;\n            pointer = ++pointer % 3;\n            if (!pointer) {\n                string += $88bbf908b96b83e8$export$4f347c1cf22bbd8.#uint24ToB64(uint24);\n                uint24 = 0;\n            }\n        }\n        return string;\n    }\n    /**\n   * Create object containing\n   */ #writeable() {\n        //\n        const tracer = {\n            writeable: true,\n            offset: this.#writePointer\n        };\n        /**\n     *\n     * @param {number} int\n     * @param {object} obj\n     * @param {number} [obj.size]\n     * @param {number} [obj.offset]\n     * @param {boolean} [obj.signed]\n     */ const append = (int, { size: size = $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(int), offset: offset = tracer.offset, signed: signed = false } = {})=>{\n            if (tracer.writeable) {\n                const uint32 = Math.abs(int);\n                const bitsRemaining = this.bitLength - offset;\n                tracer.writeable = !signed && int < 0 ? false : $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(uint32) > size ? false : !Number.isInteger(uint32) ? false : size < 0 || size > 32 ? false : size + (signed ? 1 : 0) > bitsRemaining ? false : true;\n            }\n            tracer.offset += size;\n            return {\n                append: append,\n                get isWriteable () {\n                    return tracer.writeable;\n                }\n            };\n        };\n        return {\n            append: append,\n            get isWriteable () {\n                return tracer.writeable;\n            }\n        };\n    }\n    /**\n   * Write sanitized integer directly to internal buffer, updating write\n   * pointers to the end of the written data. This private method is called by\n   * other class write methods *after* values have been checked to ensure that\n   * they are not out of range, or will not fit in the remaining empty buffer\n   * bits.\n   *\n   * @param {number} int - Integer to write to buffer.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.size] - Size of buffer segment to write in bits.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n   * @returns {number} Integer written to buffer.\n   */ #write(int, { size: size = $88bbf908b96b83e8$export$4f347c1cf22bbd8.#bitLength(int), offset: offset = this.#writePointer, signed: signed = false } = {}) {\n        // Get absolute value of integer to write.\n        const uint32 = Math.abs(int);\n        const { view: view, byteLength: byteLength, subBit: subBit } = this.#getView(size, offset);\n        for(let i = 0; i < byteLength; i++){\n            const byte = view.getUint8(i);\n            let uint8 = 0;\n            for(let j = 0; j < 8; j++){\n                const index = i * 8 + j;\n                const bit = index < subBit || index > subBit + size ? byte << 24 + j >>> 31 : uint32 << 32 - size + (index - subBit) >>> 31;\n                uint8 = uint8 | bit << 7 - j;\n            }\n            view.setUint8(i, uint8);\n        }\n        // Update write pointer and add sign bit *after* written integer.\n        // NOTE: The sign bit is written at the end of integers in the BitBuffer\n        // as this saves a bit when using the writeRelative and readRelative\n        // methods. This is because the relative size declaration can be assumed\n        // to end at the first non-zero bit (i.e. the start of the number),\n        // rather than requiring an extra \"1\" end bit if the \"1\"/\"0\" sign bit\n        // was written at the start of the number.\n        this.#writePointer = offset + size;\n        if (signed) this.#write(int >= 0 ? 1 : 0, {\n            size: 1\n        });\n        // Update last write size *after* sign bit such that the sign bit is\n        // *not* considered as the last integer size written.\n        this.#lastWriteSize = size;\n        return int;\n    }\n    /**\n   *\n   */ #readable() {\n        const tracer = {\n            readable: true,\n            offset: this.#readPointer\n        };\n        const append = (/** @type {number} */ size, { offset: offset = tracer.offset, signed: signed = false } = {})=>{\n            if (tracer.readable) {\n                const bitsRemaining = this.bitLength - offset;\n                tracer.readable = size < 0 || size > 32 ? false : size + (signed ? 1 : 0) > bitsRemaining ? false : true;\n            }\n            tracer.offset += size;\n            return {\n                append: append,\n                get isReadable () {\n                    return tracer.readable;\n                }\n            };\n        };\n        return {\n            append: append,\n            get isReadable () {\n                return tracer.readable;\n            }\n        };\n    }\n    /**\n   * Read sanitized integer directly from internal buffer, updating write\n   * pointers to the end of the read data. This private method is called by\n   * other class read methods *after* values have been checked to ensure that\n   * they are not out of range.\n   *\n   * @param {number} size - Size of buffer segment to read.\n   * @param {object} obj - Configuration object of optional arguments.\n   * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n   * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n   * @returns {number} Integer read from buffer.\n   */ #read(size, { offset: offset = this.#readPointer, signed: signed = false } = {}) {\n        const { view: view, byteLength: byteLength, subBit: subBit } = this.#getView(size, offset);\n        let uint32 = 0;\n        for(let i = 0; i < byteLength; i++){\n            const offset = 24 + subBit - i * 8;\n            uint32 = offset >= 0 ? (uint32 | view.getUint8(i) << offset) >>> 0 : (uint32 | view.getUint8(i) >>> -offset) >>> 0;\n        }\n        this.#readPointer = offset + size;\n        const sign = signed && this.#read(1) === 0 ? -1 : 1;\n        this.#lastReadSize = size;\n        return sign * (uint32 >>> 32 - size);\n    }\n    /**\n   *\n   * @param {*} size\n   * @param {*} offset\n   * @returns {{view:DataView,byteLength:number,subBit:number}} Object\n   *      containing requested dataview of BitBuffer at the given offset.\n   */ #getView(size, offset) {\n        const startByte = Math.floor(offset / 8);\n        const subBit = offset - 8 * startByte;\n        const byteLength = Math.ceil((subBit + size) / 8);\n        this.byteLength;\n        const view = new DataView(this.#buffer, startByte, byteLength);\n        return {\n            view: view,\n            byteLength: byteLength,\n            subBit: subBit\n        };\n    }\n    /**\n   * Get length of buffer in bits.\n   *\n   * @returns {number} Bit length of buffer.\n   */ get bitLength() {\n        return this.byteLength << 3;\n    }\n    /**\n   * Get length of buffer in bytes.\n   *\n   * @returns {number} Byte length of buffer.\n   */ get byteLength() {\n        return this.#buffer.byteLength;\n    }\n    /**\n   * Get current read pointer.\n   *\n   * @returns {number} Internal read pointer.\n   */ get readPointer() {\n        return this.#readPointer;\n    }\n    /**\n   * Safely set current read pointer, observing bit size of buffer.\n   *\n   * @param {number} pointer - Updated read pointer.\n   * @returns {void}\n   */ set readPointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) return;\n        // Update internal pointer.\n        this.#readPointer = pointer;\n    }\n    /**\n   * Get last read size in bits.\n   *\n   * @returns {number} Internal last read size in bits.\n   */ get lastReadSize() {\n        return this.#lastReadSize;\n    }\n    /**\n   * Safely set last read size, observing max and min integer bit sizes.\n   *\n   * @param {number} size - Updated last read size in bits.\n   * @returns {void}\n   */ set lastReadSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) return;\n        // Update internal read size.\n        this.#lastReadSize = size;\n    }\n    /**\n   * Get current write pointer.\n   *\n   * @returns {number} Internal write pointer.\n   */ get writePointer() {\n        return this.#writePointer;\n    }\n    /**\n   * Safely set current write pointer, observing bit size of buffer.\n   *\n   * @param {number} pointer - Updated write pointer.\n   * @returns {void}\n   */ set writePointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) return;\n        // Update internal pointer.\n        this.#writePointer = pointer;\n    }\n    /**\n   * Get last write size in bits.\n   *\n   * @returns {number} Internal last write size in bits.\n   */ get lastWriteSize() {\n        return this.#lastWriteSize;\n    }\n    /**\n   * Safely set last write size, observing max and min integer bit sizes.\n   *\n   * @param {number} size - Updated last write size in bits.\n   * @returns {void}\n   */ set lastWriteSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) return;\n        // Update internal write size.\n        this.#lastWriteSize = size;\n    }\n    /**\n   * Decode serialized url-safe base 64 BitBuffer string, returning a new\n   * BitBuffer instance containing the data from the original serialized\n   * buffer.\n   *\n   * @param {string} string - Url-safe base 64 encoded BitBuffer string.\n   * @returns {BitBuffer} Decoded BitBuffer instance.\n   */ static from(string) {\n        // Throw error if input string not correctly encoded.\n        if (!string.match(/^[A-Za-z0-9\\-_]*$/)) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"BitBufferError\",\n            message: \"Encoded string is not url-safe base 64 encoded\",\n            \"encoded-string\": string\n        });\n        // Create new BitBuffer instance based on length of input string.\n        const buffer = new $88bbf908b96b83e8$export$4f347c1cf22bbd8({\n            size: Math.ceil(string.length * 3 / 4)\n        });\n        // Split input string into 4-character segments, convert each segment\n        // into 24-bit unsigned integer, and write to new BitBuffer instance.\n        const regex = /[A-Za-z0-9\\-_]{1,4}/g;\n        for (const match of string.match(regex) || []){\n            const uint24 = $88bbf908b96b83e8$export$4f347c1cf22bbd8.#b64ToUint24(match.padEnd(4, \"A\"));\n            buffer.write(uint24, {\n                size: 24\n            });\n        }\n        // Reset read and write pointers.\n        buffer.writePointer = 0;\n        buffer.readPointer = 0;\n        return buffer;\n    }\n    /**\n   * Convert 4 character url-safe base 64 string to 24-bit unsigned integer.\n   *\n   * @param {string} string - 4 character url-safe base 64 string.\n   * @returns {number} Unsigned 24 bit integer.\n   */ static #b64ToUint24(string) {\n        let uint24 = 0;\n        // Loop over characters of input string, converting each url-safe base\n        // 64 character to a 6-bit integer. Bitwise SHIFT the result such that\n        // the 6 data bits occupy a unique sector of the uint24 output, and\n        // bitwise AND the result with the uint24 output.\n        for (const [index, char] of string.split(\"\").entries()){\n            const uint6 = $88bbf908b96b83e8$export$4f347c1cf22bbd8.#dict.indexOf(char);\n            uint24 = (uint24 | uint6 << 18 - index * 6) >>> 0;\n        }\n        return uint24;\n    }\n    /**\n   * Convert 24-bit unsigned integer to 4 character url-safe base 64 string.\n   *\n   * @param {number} uint24 - Unsigned 24 bit integer.\n   * @returns {string} 4 character url-safe base 64 string.\n   */ static #uint24ToB64(uint24) {\n        let string = \"\";\n        // Divide 24-bit integer into 6-bit segments, appending a url-safe base\n        // 64 character to output string for each segment.\n        for(let i = 0; i < 4; i++){\n            const uint6 = uint24 >>> 18 - i * 6 << 26 >>> 26;\n            string += $88bbf908b96b83e8$export$4f347c1cf22bbd8.#dict[uint6];\n        }\n        return string;\n    }\n    /**\n   * Get bit length of a given number.\n   *\n   * @param {number} value - Input number.\n   * @returns {number} Bit length.\n   */ static #bitLength(value) {\n        return Math.abs(value).toString(2).length;\n    }\n    /**\n   * Get url-safe base64 character dictionary, which uses different padding\n   * characters to the standard base64 encoding in node. Please see\n   * [here](https://developer.mozilla.org/en-US/docs/Glossary/Base64) for more\n   * information on base64 encoding. For url safe characters, see rfc4648\n   * [here](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n   *\n   * @returns {string} Url-safe base64 dictionary string.\n   */ static get #dict() {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"; // Url-safe padding characters for total of 64 characters.\n    }\n}\n\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Class for managing multiple workers up to a specified limit.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n * @callback workerCb\n * @returns {Worker}\n */ /**\n * @callback workerEventCb\n * @param {any} event\n * @returns {void}\n */ /**\n * @typedef {object} EnqueuedWorker\n * @property {any} message\n * @property {workerEventCb} callback\n */ // note that shared workers are not possible due to not being currently\n// available in chrome for android https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker @no-wrap\nclass $dde62425a5f151bd$export$bcff6015853c67ce {\n    #queue = /** @type {EnqueuedWorker[]} */ [];\n    #workers = /** @type {Map.<Worker, number>} */ new Map();\n    #instantiateWorker;\n    #limit;\n    /**\n   *\n   * @param {workerCb} callback\n   * @param {object} obj\n   * @param {number} [obj.limit]\n   */ constructor(callback, { limit: limit = 4 } = {}){\n        this.#instantiateWorker = callback;\n        this.#limit = limit;\n    }\n    /**\n   *\n   * @returns {Worker}\n   */ addWorker() {\n        const worker = this.#instantiateWorker();\n        this.#workers.set(worker, NaN);\n        return worker;\n    }\n    /**\n   *\n   * @param {Worker} worker\n   * @param {any} message\n   * @param {workerEventCb} callback\n   */ postWorker(worker, message, callback) {\n        this.#workers.set(worker, NaN);\n        worker.onmessage = (event)=>{\n            this.#dequeue(worker);\n            callback(event);\n        };\n        worker.postMessage(message);\n    }\n    /**\n   *\n   * @param {any} message\n   * @param {workerEventCb} callback\n   */ enqueue(message, callback) {\n        let /** @type {Worker|undefined} */ worker;\n        for (const [existingWorker, timeLastActive] of this.#workers)if (timeLastActive) {\n            worker = existingWorker;\n            break;\n        }\n        if (worker) this.postWorker(worker, message, callback);\n        else if (this.#workers.size < this.#limit) {\n            worker = this.addWorker();\n            this.postWorker(worker, message, callback);\n        } else this.#queue.push({\n            message: message,\n            callback: callback\n        });\n    }\n    /**\n   *\n   * @param {Worker} worker\n   */ #dequeue(worker) {\n        const { message: message, callback: callback } = this.#queue.shift() || {};\n        if (message && callback) this.postWorker(worker, message, callback);\n        else {\n            this.#workers.set(worker, Date.now());\n            setTimeout(()=>{\n                const timeLastActive = /** @type {number} */ this.#workers.get(worker);\n                if (Date.now() - timeLastActive > 1000) {\n                    worker.terminate();\n                    this.#workers.delete(worker);\n                }\n            }, 1050);\n        }\n    }\n}\n\n\n\n\n// @@body\nclass $3a169a73988b325e$export$15fcc258e19c8efc {\n    #luma;\n    #chromaBlue;\n    #chromaRed;\n    #total;\n    /**\n   *\n   * @param {string} subsampling\n   */ constructor(subsampling){\n        //\n        const { luma: luma, chromaBlue: chromaBlue, chromaRed: chromaRed } = subsampling.match(/^(?<luma>[0-7]):(?<chromaBlue>[0-7]):(?<chromaRed>[0-7])$/)?.groups || {};\n        //\n        if (!luma || !chromaBlue || !chromaRed) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"SubsamplingError\",\n            message: 'Must be of form \"x:y:z\", digits from 0-7 inclusive',\n            \"subsampling-string\": subsampling\n        });\n        //\n        this.#luma = parseInt(luma);\n        this.#chromaBlue = parseInt(chromaBlue);\n        this.#chromaRed = parseInt(chromaRed);\n        this.#total = this.#luma + this.#chromaBlue + this.#chromaRed;\n    }\n    /**\n   *\n   * @param {number} index\n   * @returns {\"luma\"|\"chromaBlue\"|\"chromaRed\"}\n   */ key(index) {\n        //\n        const subsample = index % this.#total;\n        //\n        return subsample < this.#luma ? \"luma\" : subsample < this.#luma + this.#chromaBlue ? \"chromaBlue\" : \"chromaRed\";\n    }\n    get luma() {\n        return this.#luma;\n    }\n    get chromaBlue() {\n        return this.#chromaBlue;\n    }\n    get chromaRed() {\n        return this.#chromaRed;\n    }\n}\n\n\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n// build dct coefficients\n/**\n *\n * @param {number} width\n * @param {number} height\n * @param {SubsampleSelector} subsampleSelector\n */ function* $858b5ee788f7e79c$export$662ff58f84a04efc(width, height, subsampleSelector) {\n    const builders = {\n        luma: $858b5ee788f7e79c$var$buildDctArray2D(width, height),\n        chromaBlue: $858b5ee788f7e79c$var$buildDctArray2D(width, height),\n        chromaRed: $858b5ee788f7e79c$var$buildDctArray2D(width, height)\n    };\n    const array3D = [\n        builders.luma.next().value,\n        builders.chromaBlue.next().value,\n        builders.chromaRed.next().value\n    ];\n    let index = 0;\n    do {\n        const value = /** @type {number} */ yield array3D;\n        const key = subsampleSelector.key(index);\n        const iteration = builders[key].next(value);\n        if (iteration.done) break;\n        key === \"luma\" ? array3D[0] = iteration.value : key === \"chromaBlue\" ? array3D[1] = iteration.value : array3D[2] = iteration.value;\n    }while (++index);\n}\n// build 2d array from diagonal\n/**\n *\n * @param {number} width\n * @param {number} height\n */ function* $858b5ee788f7e79c$var$buildDctArray2D(width, height) {\n    // /** @type {number[][]} */\n    // const array2D = Array.from(\n    //     Array.from({ length: height }),\n    //     () => Array.from({ length: width }).fill(0)\n    // )\n    const array2D = Array.from(Array.from({\n        length: width\n    }), ()=>Array.from({\n            length: height\n        }).fill(0));\n    let [x, y] = [\n        0,\n        0\n    ];\n    while(true){\n        // array2D[y][x] = /** @type {number} */ (yield array2D)\n        array2D[x][y] = /** @type {number} */ yield array2D;\n        if (y === 0 || x === width - 1) {\n            const sum = x + y + 1;\n            if (sum > width + height - 1) break;\n            y = x >= height - 1 ? height - 1 : x + 1;\n            x = sum - y;\n        } else {\n            y--;\n            x++;\n        }\n    }\n}\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Colorspace conversions for jpg dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\n/**\n * Clamp and optionally round input number between a minimum and maximum value.\n *\n * @param {number} number - Input number.\n * @param {number} minimum - Minimum value which will be returned.\n * @param {number} maximum - Maximum value which will be returned.\n * @param {boolean} isInt - Should returned value be an integer?\n * @returns {number} Clamped value.\n */ const $3a43da62ebb03d71$var$clamp = (number, minimum = 0, maximum = 255, isInt = true)=>{\n    // If should return integer, round arguments whilst respecting maximum and\n    // minimum sense of bounds (i.e. do not round minimum down or maximum up\n    // which allows numbers to be returned outside of clamp bounds).\n    if (isInt) {\n        number = Math.round(number);\n        minimum = Math.ceil(minimum);\n        maximum = Math.floor(maximum);\n    }\n    // Return clamped number.\n    return Math.max(minimum, Math.min(maximum, number));\n};\n/**\n * Convert rgb (red, green, blue) color value to YCbCr (luma, chroma blue,\n * chroma red) color value for use in jpg dct compression. Please see [this\n * section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} red - Red value of color between 0 and 255.\n * @param {number} green - Green value of color between 0 and 255.\n * @param {number} blue - Blue value of color between 0 and 255.\n * @returns {{luma:number, chromaBlue:number, chromaRed:number}} Color converted\n *      to YCbCr.\n */ const $3a43da62ebb03d71$export$251193c44da375d8 = (red, green, blue)=>{\n    // Clamp input channels to values between 0 and 255.\n    red = $3a43da62ebb03d71$var$clamp(red);\n    green = $3a43da62ebb03d71$var$clamp(green);\n    blue = $3a43da62ebb03d71$var$clamp(blue);\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        luma: $3a43da62ebb03d71$var$clamp(0.30 * red + 0.59 * green + 0.11 * blue),\n        chromaBlue: $3a43da62ebb03d71$var$clamp(128 - 0.17 * red - 0.33 * green + 0.50 * blue),\n        chromaRed: $3a43da62ebb03d71$var$clamp(128 + 0.50 * red - 0.42 * green - 0.08 * blue)\n    };\n};\n/**\n * Convert 4-channel rgba (red, green, blue, alpha) buffer into a 3-channel\n * YCbCr (luma, chroma blue, chroma red) flat data array.\n *\n * @param {Buffer} rgbaBuffer - 4-channel, rgba formatted buffer.\n * @returns 3-channel, YCbCr formatted flat data array.\n */ const $3a43da62ebb03d71$export$64581645ccce9ef7 = (rgbaBuffer)=>{\n    // Initialise flat output data array.\n    const yCbCrArray = [];\n    // Loop over input data array, fetching the luma, chroma blue, and chroma\n    // red values from the red, green, and blue input data values. Skip alpha\n    // channel, and push converted pixel data to the output array.\n    for(let i = 0; i < rgbaBuffer.length; i += 4){\n        const { luma: luma, chromaBlue: chromaBlue, chromaRed: chromaRed } = $3a43da62ebb03d71$export$251193c44da375d8(rgbaBuffer[i], rgbaBuffer[i + 1], rgbaBuffer[i + 2]);\n        yCbCrArray.push(luma, chromaBlue, chromaRed);\n    }\n    return yCbCrArray;\n};\n/**\n * Convert YCbCr (luma, chroma blue, chroma red) color value to rgb (red, green,\n * blue) color value for use in reversing colorspace used in jpg dct. Please see\n * [this section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} luma - Luma value of color between 0 and 255.\n * @param {number} chromaBlue - Chroma blue value of color between 0 and 255.\n * @param {number} chromaRed - Chroma red value of color between 0 and 255.\n * @returns {{red:number, green:number, blue:number}} Color converted to rgb.\n */ const $3a43da62ebb03d71$export$f8d5c49fa675945f = (luma, chromaBlue, chromaRed)=>{\n    // Clamp input channels to values between 0 and 255.\n    luma = $3a43da62ebb03d71$var$clamp(luma);\n    chromaBlue = $3a43da62ebb03d71$var$clamp(chromaBlue);\n    chromaRed = $3a43da62ebb03d71$var$clamp(chromaRed);\n    // Rectify chroma values such that they are between -128 and +128.\n    chromaBlue -= 128;\n    chromaRed -= 128;\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        red: $3a43da62ebb03d71$var$clamp(luma + 1.40 * chromaRed),\n        green: $3a43da62ebb03d71$var$clamp(luma - 0.34 * chromaBlue - 0.71 * chromaRed),\n        blue: $3a43da62ebb03d71$var$clamp(luma + 1.77 * chromaBlue)\n    };\n};\n/**\n * Convert 3-channel YCbCr (luma, chroma blue, chroma red) flat data array into\n * 4-channel rgba (red, green, blue, alpha) flat data array.\n *\n * @param {number[]} yCbCrArray - 3-channel, YCbCr formatted flat data array.\n * @returns 4-channel, rgba formatted flat data array.\n */ const $3a43da62ebb03d71$export$8bc460b4baf863e7 = (yCbCrArray, alpha = 255)=>{\n    // Initialise flat output data array.\n    const rgbaArray = [];\n    // Loop over input data array, fetching the red, green, and blue values from\n    // the luma, chroma blue, and chroma red input data values. Push converted\n    // pixel data to the output array with extra alpha channel.\n    for(let i = 0; i < yCbCrArray.length; i += 3){\n        const { red: red, green: green, blue: blue } = $3a43da62ebb03d71$export$f8d5c49fa675945f(yCbCrArray[i], yCbCrArray[i + 1], yCbCrArray[i + 2]);\n        rgbaArray.push(red, green, blue, alpha);\n    }\n    return rgbaArray;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Methods for decoding pixel arrays using dct compression algorithm.\n * @author James Reid\n */ // @ts-check\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */ \n/* eslint-enable no-unused-vars -- Close disable-enable pair. */ // @@body\n/**\n *\n * @param {number[][][]} array3D\n * @param {BlurridMetadata} metadata\n * @returns {number[][][]}\n */ const $4efc072bdcf08bc5$export$b24f58bb0238ca0c = (array3D, metadata)=>{\n    const [lumaDct, chromaBlueDct, chromaRedDct] = array3D;\n    const emptyChannel = ()=>{\n        return Array.from(Array.from({\n            length: metadata.image.height\n        }), ()=>Array.from({\n                length: metadata.image.width\n            }).fill(0));\n    };\n    const channels = [\n        emptyChannel(),\n        emptyChannel(),\n        emptyChannel()\n    ];\n    const [lumaChannel, chromaBlueChannel, chromaRedChannel] = channels;\n    for(let y = 0; y < metadata.image.height; y++)for(let x = 0; x < metadata.image.width; x++){\n        const point = {\n            x: x / metadata.image.width * metadata.sample.width,\n            y: y / metadata.image.height * metadata.sample.height\n        };\n        lumaChannel[y][x] = $4efc072bdcf08bc5$var$decodePixelArray2D(lumaDct, point, metadata);\n        chromaBlueChannel[y][x] = $4efc072bdcf08bc5$var$decodePixelArray2D(chromaBlueDct, point, metadata);\n        chromaRedChannel[y][x] = $4efc072bdcf08bc5$var$decodePixelArray2D(chromaRedDct, point, metadata);\n    }\n    return channels;\n};\n/**\n *\n * @param {number[][]} array2D\n * @param {{x:number, y:number}} point\n * @param {BlurridMetadata} metadata\n * @returns {number}\n */ const $4efc072bdcf08bc5$var$decodePixelArray2D = (array2D, point, metadata)=>{\n    const dctRow = [];\n    for(let i = 0; i < metadata.sample.width; i++){\n        const dctColumn = array2D[i];\n        dctRow.push($4efc072bdcf08bc5$var$decodePixelArray1D(dctColumn, point.y));\n    }\n    return $4efc072bdcf08bc5$var$decodePixelArray1D(dctRow, point.x);\n};\n// note in this implementation radians is always supplied +ve\n/**\n *\n * @param {number} radians - Angle value in radians, note that in this\n *      implementation the angle is *always* provided as a positive value.\n * @returns {number}\n */ const $4efc072bdcf08bc5$var$fastCos = (radians)=>{\n    // Rectify angle value to between 0 and 2PI radians using custom mod (while\n    // loop faster than builtin javascript `%` mod operator)\n    while(radians >= Math.PI * 2)radians -= Math.PI * 2;\n    // Rectify angle value to between 0 and PI radians (note that since angle\n    // value is *always* supplied as a positive value in this implementation,\n    // rectifying to a positive value is not required).\n    if (radians > Math.PI) radians = 2 * Math.PI - radians;\n    // Execute fastCos formula using a rearranged Bhaskara sine approximation\n    // (see here for more https://en.wikipedia.org/wiki/Bh%C4%81skara_I%27s_sine_approximation_formula) @no-wrap\n    if (radians > Math.PI / 2) {\n        radians = (radians - Math.PI) * (radians - Math.PI);\n        return 5 * radians / (radians + Math.PI * Math.PI) - 1;\n    }\n    radians *= radians;\n    return 1 - 5 * radians / (radians + Math.PI * Math.PI);\n};\n/**\n *\n * @param {number[]} array1D\n * @param {number} pointX\n * @returns {number}\n */ const $4efc072bdcf08bc5$var$decodePixelArray1D = (array1D, pointX)=>{\n    let result = 0;\n    for(let i = 0; i < array1D.length; i++){\n        let partial = array1D[i] * $4efc072bdcf08bc5$var$fastCos((2 * pointX + 1) * Math.PI * i / (2 * array1D.length));\n        partial *= i === 0 ? Math.SQRT1_2 : 1;\n        result += partial;\n    }\n    result *= Math.sqrt(2 / array1D.length);\n    result = Math.round(result);\n    return result;\n};\n\n\n// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n/**\n * @file Global variables for buffer start locations for certain data.\n * @author James Reid\n */ // @ts-check\n// @@no-imports\n// @@body\nconst $6e66e1afa51680c9$export$a0d7c623ebd339f3 = {\n    METADATA: 0,\n    SUBSAMPLING: 48,\n    COEFFICIENTS: 57,\n    ASSUMED_COEFFICIENT_SIZE: 8\n};\n\n\n\n\n// @@body\nclass $6833adc9c349e785$export$a17c6f6fb2637705 {\n    #serializedDct;\n    #buffer;\n    #metadata;\n    #coefficients;\n    /**\n   *\n   * @param {string} serializedDct\n   */ constructor(serializedDct){\n        // absolute minimum 10\n        if (!serializedDct.match(/^[A-Za-z0-9\\-_]{16,}$/)) throw new (0, $ea1325424b5d060b$export$39785c5d1570d2b1)({\n            name: \"BlurridDecoderError\",\n            message: \"String minimum 16 url-safe base 64 encoded chars\",\n            \"serialized-dct\": serializedDct\n        });\n        this.#serializedDct = serializedDct;\n        this.#buffer = (0, $88bbf908b96b83e8$export$4f347c1cf22bbd8).from(serializedDct);\n        this.#metadata = new (0, $9499b67a6b43b7b7$export$a343f46e34a234f1)(this.#deserializeMetadata());\n        this.#coefficients = this.#deserializeCoefficients();\n    }\n    toImageData() {\n        const { luma: luma, chromaBlue: chromaBlue, chromaRed: chromaRed } = this.#coefficients;\n        const array3D = [\n            luma,\n            chromaBlue,\n            chromaRed\n        ];\n        return (0, $3a43da62ebb03d71$export$8bc460b4baf863e7)((0, $8884bdd64f3f6eda$export$c28500e84d42e56e)((0, $4efc072bdcf08bc5$export$b24f58bb0238ca0c)(array3D, this.#metadata)));\n    }\n    #deserializeMetadata() {\n        //\n        this.#buffer.readPointer = (0, $6e66e1afa51680c9$export$a0d7c623ebd339f3).METADATA;\n        //\n        const image = {\n            width: this.#buffer.read(16),\n            height: this.#buffer.read(16)\n        };\n        const sample = {\n            width: this.#buffer.read(8),\n            height: this.#buffer.read(8)\n        };\n        return {\n            image: image,\n            sample: sample\n        };\n    }\n    #deserializeSubsampling() {\n        //\n        this.#buffer.readPointer = (0, $6e66e1afa51680c9$export$a0d7c623ebd339f3).SUBSAMPLING;\n        const luma = this.#buffer.read(3);\n        const chromaBlue = this.#buffer.read(3);\n        const chromaRed = this.#buffer.read(3);\n        return new (0, $3a169a73988b325e$export$15fcc258e19c8efc)(`${luma}:${chromaBlue}:${chromaRed}`);\n    }\n    #deserializeCoefficients() {\n        const dctBuilder = this.#dctBuilder();\n        let [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */ dctBuilder.next().value;\n        //\n        this.#buffer.readPointer = (0, $6e66e1afa51680c9$export$a0d7c623ebd339f3).COEFFICIENTS;\n        this.#buffer.lastReadSize = (0, $6e66e1afa51680c9$export$a0d7c623ebd339f3).ASSUMED_COEFFICIENT_SIZE;\n        /* eslint-disable-next-line no-constant-condition -- break from in while\n    loop ends loop. */ while(true){\n            const coefficient = this.#buffer.readRelative({\n                signed: true\n            });\n            if (isNaN(coefficient)) break;\n            // check if done, and break\n            [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */ dctBuilder.next(coefficient).value;\n        }\n        return {\n            luma: luma,\n            chromaBlue: chromaBlue,\n            chromaRed: chromaRed\n        };\n    }\n    #dctBuilder() {\n        //\n        return (0, $858b5ee788f7e79c$export$662ff58f84a04efc)(this.#metadata.sample.width, this.#metadata.sample.height, this.#deserializeSubsampling());\n    }\n    get serializedDct() {\n        return this.#serializedDct;\n    }\n    get metadata() {\n        return this.#metadata;\n    }\n    get coefficients() {\n        return this.#coefficients;\n    }\n}\n\n\n// @@body\nonmessage = (event)=>{\n    const decoder = new (0, $6833adc9c349e785$export$a17c6f6fb2637705)(event.data.serializedDct);\n    decoder.metadata.resize(event.data.width);\n    const imageData = new ImageData(new Uint8ClampedArray(decoder.toImageData()), decoder.metadata.image.width, decoder.metadata.image.height);\n    postMessage({\n        imageData: imageData\n    });\n}; // @@no-exports\n\n})();\n//# sourceMappingURL=worker.234ccd80.js.map\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Worker backup for generating image blur placeholders without gpu.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-package\nimport { BlurridDecoder } from \"../dct/BlurridDecoder.js\"\n\n// @@body\nonmessage = event => {\n    const decoder = new BlurridDecoder(event.data.serializedDct)\n\n    decoder.metadata.resize(event.data.width)\n    const imageData = new ImageData(\n        new Uint8ClampedArray(decoder.toImageData()),\n        decoder.metadata.image.width,\n        decoder.metadata.image.height\n    )\n\n    postMessage({ imageData })\n}\n\n// @@no-exports\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Wrapper class around blurrid dct decoding functions.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\nimport { collapseSample } from \"./array-conversions.js\"\nimport { BlurridMetadata } from \"./BlurridMetadata.js\"\nimport { buildDctArray3D } from \"./builders.js\"\nimport { yCbCrArrayToRgbaArray } from \"./colorspace-conversions.js\"\nimport { decodePixelArray3D } from \"./decode.js\"\nimport { BUFFER_LOCATIONS } from \"./serialize.js\"\nimport { SubsampleSelector } from \"./SubsampleSelector.js\"\n\n// @@imports-utils\nimport { BitBuffer, DecoratedError } from \"../utils/index.js\"\n\n// @@body\nclass BlurridDecoder {\n    #serializedDct\n    #buffer\n    #metadata\n    #coefficients\n\n    /**\n     *\n     * @param {string} serializedDct\n     */\n    constructor(serializedDct) {\n        // absolute minimum 10\n        if (!serializedDct.match(/^[A-Za-z0-9\\-_]{16,}$/)) {\n            throw new DecoratedError({\n                name: \"BlurridDecoderError\",\n                message: \"String minimum 16 url-safe base 64 encoded chars\",\n                \"serialized-dct\": serializedDct\n            })\n        }\n\n        this.#serializedDct = serializedDct\n        this.#buffer = BitBuffer.from(serializedDct)\n        this.#metadata = new BlurridMetadata(this.#deserializeMetadata())\n        this.#coefficients = this.#deserializeCoefficients()\n    }\n\n    toImageData() {\n        const { luma, chromaBlue, chromaRed } = this.#coefficients\n        const array3D = [luma, chromaBlue, chromaRed]\n\n        return yCbCrArrayToRgbaArray(\n            collapseSample(decodePixelArray3D(array3D, this.#metadata))\n        )\n    }\n\n    #deserializeMetadata() {\n        //\n        this.#buffer.readPointer = BUFFER_LOCATIONS.METADATA\n        //\n        const image = {\n            width: this.#buffer.read(16),\n            height: this.#buffer.read(16)\n        }\n        const sample = {\n            width: this.#buffer.read(8),\n            height: this.#buffer.read(8)\n        }\n\n        return { image, sample }\n    }\n\n    #deserializeSubsampling() {\n        //\n        this.#buffer.readPointer = BUFFER_LOCATIONS.SUBSAMPLING\n\n        const luma = this.#buffer.read(3)\n        const chromaBlue = this.#buffer.read(3)\n        const chromaRed = this.#buffer.read(3)\n\n        return new SubsampleSelector(`${luma}:${chromaBlue}:${chromaRed}`)\n    }\n\n    #deserializeCoefficients() {\n        const dctBuilder = this.#dctBuilder()\n        let [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */\n            (dctBuilder.next().value)\n\n        //\n        this.#buffer.readPointer = BUFFER_LOCATIONS.COEFFICIENTS\n        this.#buffer.lastReadSize = BUFFER_LOCATIONS.ASSUMED_COEFFICIENT_SIZE\n\n        /* eslint-disable-next-line no-constant-condition -- break from in while\n        loop ends loop. */\n        while (true) {\n            const coefficient = this.#buffer.readRelative({ signed: true })\n            if (isNaN(coefficient)) { break }\n\n            // check if done, and break\n            [luma, chromaBlue, chromaRed] = /** @type {number[][][]} */\n                (dctBuilder.next(coefficient).value)\n        }\n\n        return { luma, chromaBlue, chromaRed }\n    }\n\n    #dctBuilder() {\n        //\n        return buildDctArray3D(\n            this.#metadata.sample.width,\n            this.#metadata.sample.height,\n            this.#deserializeSubsampling()\n        )\n    }\n\n    get serializedDct() { return this.#serializedDct }\n\n    get metadata() { return this.#metadata }\n\n    get coefficients() { return this.#coefficients }\n}\n\n// @@exports\nexport { BlurridDecoder }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Array dimension conversions for jpg dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-utils\nimport { DecoratedError } from \"../utils/decorate-cli.js\"\n\n// @@body\n/**\n *\n * @param {number[]} sampleData\n * @param {number} width\n * @param {number} channels\n * @returns {number[][][]}\n */\nconst expandSample = (sampleData, width, channels = 3) => {\n    if (sampleData.length % channels) {\n        throw new DecoratedError({\n            name: \"ChannelError\",\n            message: \"Data length is not a multiple of requested channel count\",\n            \"data-length\": sampleData.length,\n            \"channels-requested\": channels\n        })\n    }\n\n    /** @type {number[][]} */\n    const channelData = Array.from(Array.from({ length: channels }), () => [])\n    for (const [i, pixel] of sampleData.entries()) {\n        channelData[i % channels].push(pixel)\n    }\n\n    return channelData.map(channel => expandChannel(channel, width))\n}\n\n/**\n *\n * @param {number[]} channel1D\n * @param {number} width\n * @returns {number[][]}\n */\nconst expandChannel = (channel1D, width) => {\n    if (channel1D.length % width) {\n        throw new DecoratedError({\n            name: \"ChannelError\",\n            message: \"Channel length is not a multiple of row width\",\n            \"channel-length\": channel1D.length,\n            \"row-width\": width\n        })\n    }\n\n    /** @type {number[][]} */\n    const channel2D = Array.from(\n        Array.from({ length: channel1D.length / width }),\n        () => []\n    )\n\n    for (const [i, pixel] of channel1D.entries()) {\n        channel2D[Math.floor(i / width)].push(pixel)\n    }\n\n    return channel2D\n}\n\n/**\n *\n * @param {number[][][]} expandedSample\n * @returns {number[]}\n */\nconst collapseSample = expandedSample => {\n    const channelData = expandedSample.map(channel => collapseChannel(channel))\n\n    const length = channelData[0].length\n    const sampleData = Array\n        .from({ length: channelData.length * length })\n        .fill(0)\n\n    for (const [i, channel] of channelData.entries()) {\n        if (channel.length !== length) {\n            throw new DecoratedError({\n                name: \"ChannelError\",\n                message: \"Sample channels not of same length\",\n                \"default-length\": length,\n                \"channel-length\": channel.length\n            })\n        }\n        for (const [j, pixel] of channel.entries()) {\n            sampleData[channelData.length * j + i] = pixel\n        }\n    }\n\n    return sampleData\n}\n\n/**\n *\n * @param {number[][]} channel2D\n * @returns {number[]}\n */\nconst collapseChannel = channel2D => {\n    const width = channel2D[0].length\n    const channel1D = []\n\n    for (const channelRow of channel2D) {\n        if (channelRow.length !== width) {\n            throw new DecoratedError({\n                name: \"ChannelError\",\n                message: \"Channel row width does not match sample width\",\n                \"sample-width\": length,\n                \"row-width\": channelRow.length\n            })\n        }\n        channel1D.push(...channelRow)\n    }\n\n    return channel1D\n}\n\n// @@exports\nexport { expandSample, collapseSample }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Functions for decorating cli strings.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n * Custom error which renders an error in a uniform way, taking an options\n * object with reserved name and message fields, and then any other fields\n * relevant to the error, and rendering them with indentation.\n */\nclass DecoratedError extends Error {\n    /**\n     * Build new error based on supplied options object which may set the custom\n     * name of the error, the top level message of the error, and then any\n     * number of other custom fields.\n     *\n     * @param {Object.<string,string|number|boolean>} options - Options object\n     *      containing any string keys, and string, number or boolean values.\n     */\n    constructor(options) {\n        super()\n        let message = \"\"\n\n        // Parse all properties in options argument; if key is name, use value\n        // to set the custom name of the error, if key is message, append value\n        // top of error message, otherwise render a grey, tabbed key-value\n        // pair to the end of the message string.\n        for (const key in options) {\n            switch (key) {\n                case \"name\":\n                    this.name = /** @type {string} */ (options[key])\n                    break\n                case \"message\":\n                    message = `${options[key]}\\n${message}`\n                    break\n                default: {\n                    const detail = `${key}: ${options[key]}`\n                    message = `${message}${decorateFg(detail, \"gray\", 1)}\\n`\n                }\n            }\n        }\n\n        // Set error message which will be displayed.\n        this.message = message || \"\"\n    }\n}\n\n/**\n * Decorate a string with control characters for changing cli string colors and\n * text decoration. Adds supplied list of modifiers for the string, then uses\n * reset character to set text back to default.\n *\n * @summary Return original string decorated with control characters.\n * @param {string} string - String to be decorated.\n * @param {object} options - Options object.\n * @param {string[]} [options.modifiers] - String array of modifiers/control\n *      characters to apply input string.\n * @param {number} [options.tabs] - Number of tab indents to include on string.\n * @param {number} [options.tabSize] - Number of spaces for each tab.\n * @returns {string} Original string decorated with control characters.\n */\nconst decorate = (string, { modifiers = [], tabs = 0, tabSize = 4 } = {}) => {\n    // Make compound modifier string form array of supplied control characters.\n    let compoundModifier = \"\"\n    for (const modifier of modifiers) {\n        compoundModifier = `${compoundModifier}${modifier}`\n    }\n\n    // Wrap input string with control characters and reset character.\n    const reset = cliModifiers.decorations.reset\n    const indent = \" \".repeat(tabs * tabSize)\n    return `${compoundModifier}${indent}${string}${reset}`\n}\n\n/**\n * Wrapper around decorate function to decorate a string with a foreground\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a foreground colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired foreground colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */\nconst decorateFg = (string, color, tabs = 0) => {\n    const colorModifier = cliModifiers.fgColors[color]\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier\n        ? decorate(string, { modifiers: [colorModifier], tabs })\n        : decorate(string, { tabs })\n}\n\n/**\n * Wrapper around decorate function to decorate a string with a background\n * colour control character, and optional number of tab indents.\n *\n * @summary Decorate a string with a background colour control character.\n * @param {string} string - String to be decorated.\n * @param {string} color - Desired background colour of string.\n * @param {number} [tabs=0] - Number of tab indents to include on string.\n * @returns {string} Original string decorated with color control character.\n */\nconst decorateBg = (string, color, tabs = 0) => {\n    const colorModifier = cliModifiers.bgColors[color]\n\n    // Return decorated string depending on if color resolves to valid control\n    // character from object of cli modifiers.\n    return colorModifier\n        ? decorate(string, { modifiers: [colorModifier], tabs })\n        : decorate(string, { tabs })\n}\n\n/**\n * Wrapper around String.prototype.padEnd method, which pads end of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad end of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padEnd method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */\nconst padEndDecorated = (string, maxLength, fillString) => {\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0\n    return string.padEnd(maxLength + decoratorLength, fillString)\n}\n\n/**\n * Wrapper around String.prototype.padStart method, which pads start of string\n * whilst ignoring length of control characters which will not be rendered by\n * the console (i.e. pad string such that the displayed string will be the\n * correct length when logged in the console).\n *\n * @summary Pad start of string, ignoring length of control characters.\n * @param {string} string - String to be padded.\n * @param {number} maxLength - Maximum length of string.\n * @param {string} [fillString] - Optional fill string passed to\n *      String.prototype.padStart method\n * @returns {string} Original string padded at end, ignoring length of control\n *      characters.\n */\nconst padStartDecorated = (string, maxLength, fillString) => {\n    // Calculate length of decorators in a string using control regex.\n    const decoratorLength = string.match(/\\x1b\\[\\d*m/g)?.join(\"\").length || 0\n    return string.padStart(maxLength + decoratorLength, fillString)\n}\n\n// Object of cli control strings for decorations etc.\nconst cliModifiers = {\n    // Foreground modifiers.\n    /** @type {Object.<string,string>} */\n    fgColors: {\n        black: \"\\x1b[30m\",\n        red: \"\\x1b[31m\",\n        green: \"\\x1b[32m\",\n        yellow: \"\\x1b[33m\",\n        blue: \"\\x1b[34m\",\n        magenta: \"\\x1b[35m\",\n        cyan: \"\\x1b[36m\",\n        white: \"\\x1b[37m\",\n        gray: \"\\x1b[90m\"\n    },\n\n    // Background modifiers.\n    /** @type {Object.<string,string>} */\n    bgColors: {\n        black: \"\\x1b[40m\",\n        red: \"\\x1b[41m\",\n        green: \"\\x1b[42m\",\n        yellow: \"\\x1b[43m\",\n        blue: \"\\x1b[44m\",\n        magenta: \"\\x1b[45m\",\n        cyan: \"\\x1b[46m\",\n        white: \"\\x1b[47m\",\n        gray: \"\\x1b[100m\"\n    },\n\n    // Decoration modifiers.\n    /** @type {Object.<string,string>} */\n    decorations: {\n        reset: \"\\x1b[0m\",\n        bright: \"\\x1b[1m\",\n        dim: \"\\x1b[2m\",\n        underline: \"\\x1b[4m\",\n        blink: \"\\x1b[5m\",\n        reverse: \"\\x1b[7m\",\n        hidden: \"\\x1b[8m\"\n    }\n}\n\n/**\n * Convert kebab-case string to camelCase string, removing all hyphens in input\n * string, and capitalising the first character following each hyphen. Options\n * available for generating UpperCamelCase strings, and spaced strings too.\n *\n * @summary Convert kebab-case string to camelCase string.\n * @param {string} kebabCaseString - Input kebab-case string.\n * @param {boolean} isUpper - Should return string be in UpperCamelCase?\n * @param {boolean} isSpaced - Should return string replace hyphens with\n *      whitespace characters?\n * @returns {string} camelCase string version of input.\n */\nconst toCamelCase = (kebabCaseString, isUpper = false, isSpaced = false) => {\n    // Reduce split input string with starting value object containing an empty\n    // string and flag set to isUpper for if next character should be capital.\n    return (kebabCaseString.split(\"\").reduce((acc, cur) => {\n        // Ignore hyphens, or replace with spaces as required.\n        if (cur === \"-\") {\n            return isSpaced\n                ? { string: `${acc.string} `, isCapital: true }\n                : { ...acc, isCapital: true }\n        }\n\n        // Concatenate string with next character set to uppercase if required.\n        const nextChar = acc.isCapital ? cur.toUpperCase() : cur.toLowerCase()\n        return { string: `${acc.string}${nextChar}`, isCapital: false }\n    }, { string: \"\", isCapital: isUpper }).string)\n}\n\n/**\n * Convert camelCaseString to kebab-case-string, adding hyphens between words.\n * If input string includes spaces (for example the verbatim title of a\n * markdown documentation file), replace with hyphens - this is good for\n * converting a title string to a valid kebab-case-filename. Option also\n * available for generating Upper-Kebab-Case strings.\n *\n * @summary Convert camelCaseString to kebab-case-string.\n * @param {string} camelCaseString - Input camelCaseString.\n * @param {boolean} isUpper - Should return string be in Upper-Kebab-Case?\n * @returns {string} kebab-case-string version of input.\n */\nconst toKebabCase = (camelCaseString, isUpper = false) => {\n    // Reduce split input string with starting value object containing an empty\n    // string and a new word flag set to true.\n    return (camelCaseString.split(\"\").reduce((acc, cur) => {\n        // Ignore spaces in the input string, but set new word flag to true.\n        if (cur === \" \") {\n            return { ...acc, isNewWord: true }\n        }\n\n        // If new word flag is set, or if an uppercase letter is found, insert\n        // a hyphen before appending the upper/lowercase version of the current\n        // letter depending on the isUpper argument.\n        else if (acc.isNewWord || cur.match(/[A-Z]/)) {\n            const nextChar = isUpper ? cur.toUpperCase() : cur.toLowerCase()\n            return acc.string\n                ? { string: `${acc.string}-${nextChar}`, isNewWord: false }\n                : { string: `${nextChar}`, isNewWord: false }\n        }\n\n        // Otherwise, append current letter in lowercase.\n        const nextChar = cur.toLowerCase()\n        return { string: `${acc.string}${nextChar}`, isNewWord: false }\n    }, { string: \"\", isNewWord: true }).string)\n}\n\n// @@exports\nexport {\n    DecoratedError,\n    decorate,\n    decorateFg,\n    decorateBg,\n    padEndDecorated,\n    padStartDecorated,\n    cliModifiers,\n    toCamelCase,\n    toKebabCase\n}\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Class for building and accessing dct metadata.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\nclass BlurridMetadata {\n    #image\n    #sample\n\n    /**\n     *\n     * @param {object} obj\n     * @param {object} obj.image\n     * @param {number} obj.image.width\n     * @param {number} obj.image.height\n     * @param {object} obj.sample\n     * @param {number} obj.sample.width\n     * @param {number} obj.sample.height\n     */\n    constructor({ image, sample }) {\n        this.#image = image\n        this.#sample = { ...sample, max: Math.max(sample.width, sample.height) }\n    }\n\n    /**\n     *\n     * @param {number} width\n     */\n    resize(width) {\n        this.#image.height = Math\n            .round(this.#image.height * width / this.#image.width)\n        this.#image.width = width\n    }\n\n    get image() { return this.#image }\n\n    get sample() { return this.#sample }\n}\n\n// @@exports\nexport { BlurridMetadata }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Generators for building arrays of dct coefficients.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { SubsampleSelector } from \"./SubsampleSelector.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n// build dct coefficients\n/**\n *\n * @param {number} width\n * @param {number} height\n * @param {SubsampleSelector} subsampleSelector\n */\nfunction* buildDctArray3D(width, height, subsampleSelector) {\n    const builders = {\n        luma: buildDctArray2D(width, height),\n        chromaBlue: buildDctArray2D(width, height),\n        chromaRed: buildDctArray2D(width, height)\n    }\n    const array3D = [\n        builders.luma.next().value,\n        builders.chromaBlue.next().value,\n        builders.chromaRed.next().value,\n    ]\n\n    let index = 0\n    do {\n        const value = /** @type {number} */ (yield array3D)\n        const key = subsampleSelector.key(index)\n\n        const iteration = builders[key].next(value)\n        if (iteration.done) { break }\n        key === \"luma\" ? array3D[0] = iteration.value\n            : key === \"chromaBlue\" ? array3D[1] = iteration.value\n            : array3D[2] = iteration.value\n    } while (++index)\n}\n\n// build 2d array from diagonal\n/**\n *\n * @param {number} width\n * @param {number} height\n */\nfunction* buildDctArray2D(width, height) {\n    // /** @type {number[][]} */\n    // const array2D = Array.from(\n    //     Array.from({ length: height }),\n    //     () => Array.from({ length: width }).fill(0)\n    // )\n    const array2D = Array.from(\n        Array.from({ length: width }),\n        () => Array.from({ length: height }).fill(0)\n    )\n    let [x, y] = [0, 0]\n\n    while (true) {\n        // array2D[y][x] = /** @type {number} */ (yield array2D)\n        array2D[x][y] = /** @type {number} */ (yield array2D)\n\n        if (y === 0 || x === width - 1) {\n            const sum = x + y + 1\n            if (sum > width + height - 1) { break }\n            y = x >= height - 1 ? height - 1 : x + 1\n            x = sum - y\n        }\n        else { y--; x++ }\n    }\n}\n\n// @@exports\nexport { buildDctArray3D }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Class for processing subsample strings.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-utils\nimport { DecoratedError } from \"../utils/index.js\"\n\n// @@body\nclass SubsampleSelector {\n    #luma\n    #chromaBlue\n    #chromaRed\n    #total\n\n    /**\n     *\n     * @param {string} subsampling\n     */\n    constructor(subsampling) {\n        //\n        const { luma, chromaBlue, chromaRed } = subsampling\n            .match(/^(?<luma>[0-7]):(?<chromaBlue>[0-7]):(?<chromaRed>[0-7])$/)\n            ?.groups || {}\n\n        //\n        if (!luma || !chromaBlue || !chromaRed) {\n            throw new DecoratedError({\n                name: \"SubsamplingError\",\n                message: \"Must be of form \\\"x:y:z\\\", digits from 0-7 inclusive\",\n                \"subsampling-string\": subsampling\n            })\n        }\n\n        //\n        this.#luma = parseInt(luma)\n        this.#chromaBlue = parseInt(chromaBlue)\n        this.#chromaRed = parseInt(chromaRed)\n        this.#total = this.#luma + this.#chromaBlue + this.#chromaRed\n    }\n\n    /**\n     *\n     * @param {number} index\n     * @returns {\"luma\"|\"chromaBlue\"|\"chromaRed\"}\n     */\n    key(index) {\n        //\n        const subsample = index % this.#total\n\n        //\n        return subsample < this.#luma ? \"luma\"\n            : subsample < this.#luma + this.#chromaBlue ? \"chromaBlue\"\n            : \"chromaRed\"\n    }\n\n    get luma() { return this.#luma }\n\n    get chromaBlue() { return this.#chromaBlue }\n\n    get chromaRed() { return this.#chromaRed }\n}\n\n// @@exports\nexport { SubsampleSelector }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Export utility methods.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@no-body\n\n// @@exports\nexport * from \"./BitBuffer.js\"\nexport * from \"./decorate-cli.js\"\nexport * from \"./WorkerManager.js\"\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Buffer class allowing control at bit level rather than byte level.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-module\nimport { DecoratedError } from \"./decorate-cli.js\"\n\n// @@body\n/**\n * Buffer class allowing control over an appropriately sized array buffer at the\n * bit level rather than at the byte level.\n */\nclass BitBuffer {\n    #buffer\n    #readPointer\n    #lastReadSize\n    #writePointer\n    #lastWriteSize\n\n    /**\n     * Configure internal buffer property and required pointers.\n     *\n     * @param {object} obj - Configuration object argument.\n     * @param {number} [obj.length] - Maximum character length of buffer when\n     *      converted to url-safe base64 string.\n     * @param {number} [obj.size] - Size of BitBuffer in *bytes*. Defaults to\n     *      maximum allowable size as specified by the character length value.\n     * @param {ArrayBuffer} [obj.buffer] - Internal array buffer.\n     */\n    constructor({\n        length = 16,\n        size = Math.floor(length * 6 / 8),\n        buffer = new ArrayBuffer(size)\n    } = {}) {\n        // Assign internal array buffer for implementation of BitBuffer.\n        this.#buffer = buffer\n\n        // Assign internal read pointers.\n        this.#readPointer = 0\n        this.#lastReadSize = 0\n\n        // Assign internal write pointers.\n        this.#writePointer = 0\n        this.#lastWriteSize = 0\n    }\n\n    /**\n     * Write an integer directly to internal buffer, updating write pointers to\n     * the end of the written data.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.size] - Size of buffer segment to write in bits.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    write(int, {\n        size = BitBuffer.#bitLength(int),\n        offset = this.#writePointer,\n        signed = false\n    } = {}) {\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable()\n            .append(int, { size, offset, signed })\n        if (!writeable.isWriteable) { return NaN }\n\n        return this.#write(int, { size, offset, signed })\n    }\n\n    /**\n     * Write an integer to internal buffer with an absolute size declaration to\n     * indicate how many bits are written (i.e. 5 additional bits written\n     * indicating length of written data between 0 and 32 bits). Update write\n     * pointers to the end of the written data.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    writeAbsolute(int, { offset = this.#writePointer, signed = false } = {}) {\n        // Size declaration data with the size of buffer segment it will occupy.\n        const resize = { value: BitBuffer.#bitLength(int), size: 5 }\n\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable()\n            .append(resize.value, { ...resize, offset })\n            .append(int, { signed })\n        if (!writeable.isWriteable) { return NaN }\n\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, { ...resize, offset })\n        const uint32 = this.#write(int, { signed })\n\n        return uint32\n    }\n\n    /**\n     * Write an integer to internal buffer with a relative size declaration to\n     * indicate how many bits are written (i.e. 1 \"sign\" bit to indicate if more\n     * or less bits than the previous write call are being written, and n \"0\"\n     * bits where n is the relative size between the previous and next write\n     * call sizes). Update write pointers to the end of the written data.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    writeRelative(int, { offset = this.#writePointer, signed = false } = {}) {\n        // Write relative method relies on the first bit of the written integer\n        // being \"1\", and therefore cannot write integer \"0\".\n        if (int === 0) { int = 1 }\n\n        // Size declaration data with the size of buffer segment it will occupy.\n        const relativeSize = BitBuffer.#bitLength(int) - this.#lastWriteSize\n        const resize = {\n            // If increasing size, write a 1 bit shifted by the amount of bits\n            // the data is bigger by, otherwise write a 0. Preserve required\n            // bit length of size declaration using size property.\n            value: relativeSize > 0 ? (1 << relativeSize) >>> 0 : 0,\n            size: Math.abs(relativeSize) + 1\n        }\n\n        // If all values are not writeable due to insufficient bits remaining\n        // etc., then return no number.\n        const writeable = this.#writeable()\n            .append(resize.value, { ...resize, offset })\n            .append(int, { signed })\n        if (!writeable.isWriteable) { return NaN }\n\n        // Write both size declaration data and integer to buffer.\n        this.#write(resize.value, { ...resize, offset })\n        const uint32 = this.#write(int, { signed })\n\n        return uint32\n    }\n\n    /**\n     * Write a string of arbitrary length to the internal buffer.\n     *\n     * @param {string} string - String to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @returns {string} String written to buffer.\n     */\n    writeString(string, { offset = this.#writePointer } = {}) {\n        // Size declaration data for bit length of length of string declaration.\n        const resize = {\n            value: BitBuffer.#bitLength(string.length),\n            size: 5\n        }\n\n        // If all characters are not writeable due to insufficient bits\n        // remaining etc., then return empty string.\n        let writeable = this.#writeable()\n            .append(resize.value, { ...resize })\n            .append(string.length)\n        for (let i = 0; i < string.length; i++) {\n            writeable = writeable.append(0, { size: 8 })\n        }\n        if (!writeable.isWriteable) { return \"\" }\n\n        // Write string length declaration and string to buffer.\n        this.#write(resize.value, { ...resize, offset })\n        this.#write(string.length)\n        for (const char of string) {\n            this.#write(char.charCodeAt(0), { size: 8 })\n        }\n\n        return string\n    }\n\n    /**\n     * Read an integer directly from internal buffer, updating read pointers to\n     * the end of the read data.\n     *\n     * @param {number} size - Size of buffer segment to read.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    read(size, { offset = this.#readPointer, signed = false } = {}) {\n        // If all values are not readable due to insufficient bits remaining\n        // etc., then return no number.\n        const readable = this.#readable().append(size, { offset, signed })\n        if (!readable.isReadable) { return NaN }\n\n        return this.#read(size, { offset, signed })\n    }\n\n    /**\n     * Read an integer from internal buffer, determining bit size of segment\n     * by reading an absolute size declaration from the buffer indicating how\n     * many bits should be read (i.e. 5 additional bits read before reading\n     * integer to determine bit size of read segment between 0 and 32 bits).\n     * Update read pointers to the end of the read data.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    readAbsolute({ offset = this.#readPointer, signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer\n        const lastReadSize = this.#lastReadSize\n\n        // Check if sufficient read bits remain to read both the size\n        // declaration and integer.\n        const readable = this.#readable().append(5, { offset })\n        let size = 0\n        if (readable.isReadable) {\n            size = this.#read(5, { offset })\n            readable.append(size, { signed })\n        }\n\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer\n            this.#lastReadSize = lastReadSize\n            return NaN\n        }\n\n        return this.#read(size, { signed })\n    }\n\n    /**\n     * Read an integer from internal buffer, determining bit size of segment by\n     * reading a relative size declaration from the buffer indicating how many\n     * bit should be read (i.e. 1 \"sign\" bit to indicate if more or less bits\n     * than the previous read call are being read, and n \"0\" bits where n is the\n     * relative size between the previous and next read call sizes). Update read\n     * pointers to the end of the read data.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    readRelative({ offset = this.#readPointer, signed = false } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer\n        const lastReadSize = this.#lastReadSize\n\n        // Get sign of relative size (i.e. are more or less bits to be read than\n        // last read call).\n        let sign = 1\n        const readable = this.#readable().append(1, { offset })\n        if (readable.isReadable) { sign = this.#read(1, { offset }) ? 1 : - 1 }\n\n        // Get unsigned read size relative to size of last read call (reads\n        // until first bit of integer to be read, then breaks).\n        let relativeSize = 0\n        while (readable.append(1).isReadable) {\n            if (this.#read(1)) { break }\n            relativeSize++\n        }\n\n        // Get size of integer to be read from buffer.\n        const size = lastReadSize + sign * relativeSize\n        readable.append(size, { signed })\n\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !size) {\n            this.#readPointer = readPointer\n            this.#lastReadSize = lastReadSize\n            return NaN\n        }\n\n        // Decrement read pointer to account for first bit of integer having\n        // been read above.\n        this.#readPointer--\n\n        return this.#read(size, { signed })\n    }\n\n    /**\n     * Read a string of arbitrary length from the internal buffer.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @returns {string} String read from buffer.\n     */\n    readString({ offset = this.#readPointer } = {}) {\n        // Record read pointers for resetting if required.\n        const readPointer = this.#readPointer\n        const lastReadSize = this.#lastReadSize\n\n        // Get bit size of string length declaration.\n        const readable = this.#readable().append(5, { offset })\n        let lengthSize = 0\n        if (readable.isReadable) { lengthSize = this.#read(5, { offset }) }\n        readable.append(lengthSize)\n\n        // Get string length.\n        let length = 0\n        if (readable.isReadable) { length = this.#read(lengthSize) }\n\n        // Reset pointers and return no number if insufficient remaining read\n        // bits.\n        if (!readable.isReadable || !length) {\n            this.#readPointer = readPointer\n            this.#lastReadSize = lastReadSize\n            return \"\"\n        }\n\n        let string = \"\"\n        for (let i = 0; i < length; i++) {\n            // Ensure next byte (8 bit character) is readable.\n            readable.append(8)\n\n            // Reset pointers and return no number if insufficient remaining\n            // read bits.\n            if (!readable.isReadable) {\n                this.#readPointer = readPointer\n                this.#lastReadSize = lastReadSize\n                return \"\"\n            }\n\n            // Read character from buffer and append to string.\n            string += String.fromCharCode(this.#read(8))\n        }\n\n        return string\n    }\n\n    /**\n     * Copy data from source buffer (current buffer instance) to a target buffer\n     * passed in the arguments. If no target buffer passed, new BitBuffer\n     * instantiated with a length based on number of copied bits. Will update\n     * read/write pointers in both source and target buffers.\n     *\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {BitBuffer} [obj.target] - Target buffer to copy to.\n     * @param {number} [obj.targetStart] - Start bit in target buffer.\n     * @param {number} [obj.sourceStart] - Start bit in source buffer.\n     * @param {number} [obj.sourceEnd] - End bit in source buffer.\n     * @returns {BitBuffer} Target buffer with data copied from source buffer.\n     */\n    copy({\n        target,\n        targetStart = target?.writePointer || 0,\n        sourceStart = 0,\n        sourceEnd = this.bitLength\n    } = {}) {\n        // Throw error if source start or end bounds are out of buffer range.\n        if (sourceStart < 0 || sourceEnd > this.bitLength) {\n            throw new DecoratedError({\n                name: \"BitBufferError\",\n                message: \"Requested bits out of source buffer range\",\n                \"source-start\": sourceStart,\n                \"source-end\": sourceEnd,\n                \"source-bit-length\": this.bitLength\n            })\n        }\n\n        // Get number of source bits, and minimum size of target buffer in bytes\n        // to store the data from the source buffer.\n        const sourceBits = sourceEnd - sourceStart\n        const targetSize = Math.ceil((sourceBits + targetStart) / 8)\n\n        // Get available write bits in target buffer, instantiating a BitBuffer\n        // of the correct size if none is passed in arguments.\n        target ??= new BitBuffer({ size: targetSize })\n        const targetBits = target.bitLength - targetStart\n\n        // Throw error if not sufficient bits remaining in target buffer.\n        if (sourceBits > targetBits) {\n            throw new DecoratedError({\n                name: \"BitBufferError\",\n                message: \"Source bits exceed bits available in target buffer\",\n                \"source-bits\": sourceBits,\n                \"target-bits\": targetBits\n            })\n        }\n\n        // Copy data bits from source buffer to target buffer.\n        for (let i = 0; i < sourceBits; i++) {\n            target.write(\n                this.#read(1, { offset: sourceStart + i }),\n                { size: 1, offset: targetStart + i }\n            )\n        }\n\n        return target\n    }\n\n    /**\n     * Convert buffer to serialized string of base-64 url-safe characters.\n     *\n     * @returns {string} Serialized buffer string.\n     */\n    toString() {\n        // Initialize serialized string and pointers to track string fragments.\n        let string = \"\"\n        let pointer = 0\n        let uint24 = 0\n\n        // Loop over buffer, adding 4 character fragments to serialized string\n        // for every 24 bits consumed from buffer (24-bit blocks consumed in\n        // 3-byte blocks at time).\n        const view = new Uint8Array(this.#buffer)\n        for (let i = 0; i < Math.ceil(this.byteLength / 3) * 3; i++) {\n            const byte = view[i] || 0\n            uint24 = (uint24 | (byte << 16 - pointer * 8)) >>> 0\n            pointer = ++pointer % 3\n            if (!pointer) {\n                string += BitBuffer.#uint24ToB64(uint24)\n                uint24 = 0\n            }\n        }\n\n        return string\n    }\n\n    /**\n     * Create object containing\n     */\n    #writeable() {\n        //\n        const tracer = { writeable: true, offset: this.#writePointer }\n\n        /**\n         *\n         * @param {number} int\n         * @param {object} obj\n         * @param {number} [obj.size]\n         * @param {number} [obj.offset]\n         * @param {boolean} [obj.signed]\n         */\n        const append = (int, {\n            size = BitBuffer.#bitLength(int),\n            offset = tracer.offset,\n            signed = false\n        } = {}) => {\n            if (tracer.writeable) {\n                const uint32 = Math.abs(int)\n                const bitsRemaining = this.bitLength - offset\n\n                tracer.writeable = !signed && int < 0 ? false\n                    : BitBuffer.#bitLength(uint32) > size ? false\n                    : !Number.isInteger(uint32) ? false\n                    : size < 0 || size > 32 ? false\n                    : size + (signed ? 1 : 0) > bitsRemaining ? false\n                    : true\n            }\n\n            tracer.offset += size\n\n            return { append, get isWriteable() { return tracer.writeable } }\n        }\n\n        return { append, get isWriteable() { return tracer.writeable } }\n    }\n\n    /**\n     * Write sanitized integer directly to internal buffer, updating write\n     * pointers to the end of the written data. This private method is called by\n     * other class write methods *after* values have been checked to ensure that\n     * they are not out of range, or will not fit in the remaining empty buffer\n     * bits.\n     *\n     * @param {number} int - Integer to write to buffer.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.size] - Size of buffer segment to write in bits.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Write signed or unsigned integer.\n     * @returns {number} Integer written to buffer.\n     */\n    #write(int, {\n        size = BitBuffer.#bitLength(int),\n        offset = this.#writePointer,\n        signed = false\n    } = {}) {\n        // Get absolute value of integer to write.\n        const uint32 = Math.abs(int)\n\n        const { view, byteLength, subBit } = this.#getView(size, offset)\n        for (let i = 0; i < byteLength; i++) {\n            const byte = view.getUint8(i)\n            let uint8 = 0\n            for (let j = 0; j < 8; j++) {\n                const index = i * 8 + j\n                const bit = index < subBit || index > subBit + size\n                    ? byte << 24 + j >>> 31\n                    : uint32 << (32 - size) + (index - subBit) >>> 31\n                uint8 = uint8 | (bit << 7 - j)\n            }\n            view.setUint8(i, uint8)\n        }\n\n        // Update write pointer and add sign bit *after* written integer.\n        // NOTE: The sign bit is written at the end of integers in the BitBuffer\n        // as this saves a bit when using the writeRelative and readRelative\n        // methods. This is because the relative size declaration can be assumed\n        // to end at the first non-zero bit (i.e. the start of the number),\n        // rather than requiring an extra \"1\" end bit if the \"1\"/\"0\" sign bit\n        // was written at the start of the number.\n        this.#writePointer = offset + size\n        if (signed) { this.#write(int >= 0 ? 1 : 0, { size: 1 }) }\n\n        // Update last write size *after* sign bit such that the sign bit is\n        // *not* considered as the last integer size written.\n        this.#lastWriteSize = size\n\n        return int\n    }\n\n    /**\n     *\n     */\n    #readable() {\n        const tracer = { readable: true, offset: this.#readPointer }\n\n        const append = (/** @type {number} */ size, {\n            offset = tracer.offset,\n            signed = false\n        } = {}) => {\n            if (tracer.readable) {\n                const bitsRemaining = this.bitLength - offset\n\n                tracer.readable = size < 0 || size > 32 ? false\n                    : size + (signed ? 1 : 0) > bitsRemaining ? false\n                    : true\n            }\n\n            tracer.offset += size\n\n            return { append, get isReadable() { return tracer.readable } }\n        }\n\n        return { append, get isReadable() { return tracer.readable } }\n    }\n\n    /**\n     * Read sanitized integer directly from internal buffer, updating write\n     * pointers to the end of the read data. This private method is called by\n     * other class read methods *after* values have been checked to ensure that\n     * they are not out of range.\n     *\n     * @param {number} size - Size of buffer segment to read.\n     * @param {object} obj - Configuration object of optional arguments.\n     * @param {number} [obj.offset] - Offset of segment within buffer in bits.\n     * @param {boolean} [obj.signed] - Read signed or unsigned integer.\n     * @returns {number} Integer read from buffer.\n     */\n    #read(size, { offset = this.#readPointer, signed = false } = {}) {\n        const { view, byteLength, subBit } = this.#getView(size, offset)\n        let uint32 = 0\n        for (let i = 0; i < byteLength; i++) {\n            const offset = 24 + subBit - i * 8\n            uint32 = offset >= 0\n                ? (uint32 | view.getUint8(i) << offset) >>> 0\n                : (uint32 | view.getUint8(i) >>> - offset) >>> 0\n        }\n\n        this.#readPointer = offset + size\n        const sign = signed && this.#read(1) === 0 ? - 1 : 1\n\n        this.#lastReadSize = size\n\n        return sign * (uint32 >>> 32 - size)\n    }\n\n    /**\n     *\n     * @param {*} size\n     * @param {*} offset\n     * @returns {{view:DataView,byteLength:number,subBit:number}} Object\n     *      containing requested dataview of BitBuffer at the given offset.\n     */\n    #getView(size, offset) {\n        const startByte = Math.floor(offset / 8)\n        const subBit = offset - 8 * startByte\n        const byteLength = Math.ceil((subBit + size) / 8)\n        if (startByte + byteLength > this.byteLength) {\n            // throw new BitBuffer.#RangeError(size, offset)\n        }\n        const view = new DataView(this.#buffer, startByte, byteLength)\n        return { view, byteLength, subBit }\n    }\n\n    /**\n     * Get length of buffer in bits.\n     *\n     * @returns {number} Bit length of buffer.\n     */\n    get bitLength() { return this.byteLength << 3 }\n\n    /**\n     * Get length of buffer in bytes.\n     *\n     * @returns {number} Byte length of buffer.\n     */\n    get byteLength() { return this.#buffer.byteLength }\n\n    /**\n     * Get current read pointer.\n     *\n     * @returns {number} Internal read pointer.\n     */\n    get readPointer() { return this.#readPointer }\n\n    /**\n     * Safely set current read pointer, observing bit size of buffer.\n     *\n     * @param {number} pointer - Updated read pointer.\n     * @returns {void}\n     */\n    set readPointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) { return }\n\n        // Update internal pointer.\n        this.#readPointer = pointer\n    }\n\n    /**\n     * Get last read size in bits.\n     *\n     * @returns {number} Internal last read size in bits.\n     */\n    get lastReadSize() { return this.#lastReadSize }\n\n    /**\n     * Safely set last read size, observing max and min integer bit sizes.\n     *\n     * @param {number} size - Updated last read size in bits.\n     * @returns {void}\n     */\n    set lastReadSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) { return }\n\n        // Update internal read size.\n        this.#lastReadSize = size\n    }\n\n    /**\n     * Get current write pointer.\n     *\n     * @returns {number} Internal write pointer.\n     */\n    get writePointer() { return this.#writePointer }\n\n    /**\n     * Safely set current write pointer, observing bit size of buffer.\n     *\n     * @param {number} pointer - Updated write pointer.\n     * @returns {void}\n     */\n    set writePointer(pointer) {\n        // Ignore updated pointer if it is out of range.\n        if (pointer < 0 || pointer > this.bitLength) { return }\n\n        // Update internal pointer.\n        this.#writePointer = pointer\n    }\n\n    /**\n     * Get last write size in bits.\n     *\n     * @returns {number} Internal last write size in bits.\n     */\n    get lastWriteSize() { return this.#lastWriteSize }\n\n    /**\n     * Safely set last write size, observing max and min integer bit sizes.\n     *\n     * @param {number} size - Updated last write size in bits.\n     * @returns {void}\n     */\n    set lastWriteSize(size) {\n        // Ignore updated size if not within max and min integer bit sizes.\n        if (size < 0 || size > 32) { return }\n\n        // Update internal write size.\n        this.#lastWriteSize = size\n    }\n\n    /**\n     * Decode serialized url-safe base 64 BitBuffer string, returning a new\n     * BitBuffer instance containing the data from the original serialized\n     * buffer.\n     *\n     * @param {string} string - Url-safe base 64 encoded BitBuffer string.\n     * @returns {BitBuffer} Decoded BitBuffer instance.\n     */\n    static from(string) {\n        // Throw error if input string not correctly encoded.\n        if (!string.match(/^[A-Za-z0-9\\-_]*$/)) {\n            throw new DecoratedError({\n                name: \"BitBufferError\",\n                message: \"Encoded string is not url-safe base 64 encoded\",\n                \"encoded-string\": string\n            })\n        }\n\n        // Create new BitBuffer instance based on length of input string.\n        const buffer = new BitBuffer({ size: Math.ceil(string.length * 3 / 4) })\n\n        // Split input string into 4-character segments, convert each segment\n        // into 24-bit unsigned integer, and write to new BitBuffer instance.\n        const regex = /[A-Za-z0-9\\-_]{1,4}/g\n        for (const match of string.match(regex) || []) {\n            const uint24 = BitBuffer.#b64ToUint24(match.padEnd(4, \"A\"))\n            buffer.write(uint24, { size: 24 })\n        }\n\n        // Reset read and write pointers.\n        buffer.writePointer = 0\n        buffer.readPointer = 0\n\n        return buffer\n    }\n\n    /**\n     * Convert 4 character url-safe base 64 string to 24-bit unsigned integer.\n     *\n     * @param {string} string - 4 character url-safe base 64 string.\n     * @returns {number} Unsigned 24 bit integer.\n     */\n    static #b64ToUint24(string) {\n        let uint24 = 0\n\n        // Loop over characters of input string, converting each url-safe base\n        // 64 character to a 6-bit integer. Bitwise SHIFT the result such that\n        // the 6 data bits occupy a unique sector of the uint24 output, and\n        // bitwise AND the result with the uint24 output.\n        for (const [index, char] of string.split(\"\").entries()) {\n            const uint6 = BitBuffer.#dict.indexOf(char)\n            uint24 = (uint24 | (uint6 << 18 - index * 6)) >>> 0\n        }\n\n        return uint24\n    }\n\n    /**\n     * Convert 24-bit unsigned integer to 4 character url-safe base 64 string.\n     *\n     * @param {number} uint24 - Unsigned 24 bit integer.\n     * @returns {string} 4 character url-safe base 64 string.\n     */\n    static #uint24ToB64(uint24) {\n        let string = \"\"\n\n        // Divide 24-bit integer into 6-bit segments, appending a url-safe base\n        // 64 character to output string for each segment.\n        for (let i = 0; i < 4; i++) {\n            const uint6 = uint24 >>> 18 - i * 6 << 26 >>> 26\n            string += BitBuffer.#dict[uint6]\n        }\n\n        return string\n    }\n\n    /**\n     * Get bit length of a given number.\n     *\n     * @param {number} value - Input number.\n     * @returns {number} Bit length.\n     */\n    static #bitLength(value) { return Math.abs(value).toString(2).length }\n\n    /**\n     * Get url-safe base64 character dictionary, which uses different padding\n     * characters to the standard base64 encoding in node. Please see\n     * [here](https://developer.mozilla.org/en-US/docs/Glossary/Base64) for more\n     * information on base64 encoding. For url safe characters, see rfc4648\n     * [here](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @returns {string} Url-safe base64 dictionary string.\n     */\n    static get #dict() {\n        return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + // Uppercase alpha characters.\n            \"abcdefghijklmnopqrstuvwxyz\" + // Lowercase alpha characters.\n            \"0123456789\" + // Number characters.\n            \"-_\" // Url-safe padding characters for total of 64 characters.\n    }\n}\n\n// @@exports\nexport { BitBuffer }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Class for managing multiple workers up to a specified limit.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n * @callback workerCb\n * @returns {Worker}\n */\n\n/**\n * @callback workerEventCb\n * @param {any} event\n * @returns {void}\n */\n\n/**\n * @typedef {object} EnqueuedWorker\n * @property {any} message\n * @property {workerEventCb} callback\n */\n\n// note that shared workers are not possible due to not being currently\n// available in chrome for android https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker @no-wrap\nclass WorkerManager {\n    #queue = /** @type {EnqueuedWorker[]} */ ([])\n    #workers = /** @type {Map.<Worker, number>} */ (new Map())\n    #instantiateWorker\n    #limit\n\n    /**\n     *\n     * @param {workerCb} callback\n     * @param {object} obj\n     * @param {number} [obj.limit]\n     */\n    constructor(callback, { limit = 4 } = {}) {\n        this.#instantiateWorker = callback\n        this.#limit = limit\n    }\n\n    /**\n     *\n     * @returns {Worker}\n     */\n    addWorker() {\n        const worker = this.#instantiateWorker()\n        this.#workers.set(worker, NaN)\n        return worker\n    }\n\n    /**\n     *\n     * @param {Worker} worker\n     * @param {any} message\n     * @param {workerEventCb} callback\n     */\n    postWorker(worker, message, callback) {\n        this.#workers.set(worker, NaN)\n        worker.onmessage = event => {\n            this.#dequeue(worker)\n            callback(event)\n        }\n        worker.postMessage(message)\n    }\n\n    /**\n     *\n     * @param {any} message\n     * @param {workerEventCb} callback\n     */\n    enqueue(message, callback) {\n        let /** @type {Worker|undefined} */ worker\n        for (const [existingWorker, timeLastActive] of this.#workers) {\n            if (timeLastActive) {\n                worker = existingWorker\n                break\n            }\n        }\n\n        if (worker) { this.postWorker(worker, message, callback) }\n        else if (this.#workers.size < this.#limit) {\n            worker = this.addWorker()\n            this.postWorker(worker, message, callback)\n        }\n        else { this.#queue.push({ message, callback }) }\n    }\n\n    /**\n     *\n     * @param {Worker} worker\n     */\n    #dequeue(worker) {\n        const { message, callback } = this.#queue.shift() || {}\n        if (message && callback) {\n            this.postWorker(worker, message, callback)\n        }\n        else {\n            this.#workers.set(worker, Date.now())\n            setTimeout(() => {\n                const timeLastActive = /** @type {number} */\n                    (this.#workers.get(worker))\n                if (Date.now() - timeLastActive > 1000) {\n                    worker.terminate()\n                    this.#workers.delete(worker)\n                }\n            }, 1050)\n        }\n    }\n}\n\n// @@exports\nexport { WorkerManager }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Colorspace conversions for jpg dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\n/**\n * Clamp and optionally round input number between a minimum and maximum value.\n *\n * @param {number} number - Input number.\n * @param {number} minimum - Minimum value which will be returned.\n * @param {number} maximum - Maximum value which will be returned.\n * @param {boolean} isInt - Should returned value be an integer?\n * @returns {number} Clamped value.\n */\nconst clamp = (number, minimum = 0, maximum = 255, isInt = true) => {\n    // If should return integer, round arguments whilst respecting maximum and\n    // minimum sense of bounds (i.e. do not round minimum down or maximum up\n    // which allows numbers to be returned outside of clamp bounds).\n    if (isInt) {\n        number = Math.round(number)\n        minimum = Math.ceil(minimum)\n        maximum = Math.floor(maximum)\n    }\n\n    // Return clamped number.\n    return Math.max(minimum, Math.min(maximum, number))\n}\n\n/**\n * Convert rgb (red, green, blue) color value to YCbCr (luma, chroma blue,\n * chroma red) color value for use in jpg dct compression. Please see [this\n * section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} red - Red value of color between 0 and 255.\n * @param {number} green - Green value of color between 0 and 255.\n * @param {number} blue - Blue value of color between 0 and 255.\n * @returns {{luma:number, chromaBlue:number, chromaRed:number}} Color converted\n *      to YCbCr.\n */\nconst rgbToYCbCr = (red, green, blue) => {\n    // Clamp input channels to values between 0 and 255.\n    red = clamp(red)\n    green = clamp(green)\n    blue = clamp(blue)\n\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        luma: clamp(0.30 * red + 0.59 * green + 0.11 * blue),\n        chromaBlue: clamp(128 - 0.17 * red - 0.33 * green + 0.50 * blue),\n        chromaRed: clamp(128 + 0.50 * red - 0.42 * green - 0.08 * blue)\n    }\n}\n\n/**\n * Convert 4-channel rgba (red, green, blue, alpha) buffer into a 3-channel\n * YCbCr (luma, chroma blue, chroma red) flat data array.\n *\n * @param {Buffer} rgbaBuffer - 4-channel, rgba formatted buffer.\n * @returns 3-channel, YCbCr formatted flat data array.\n */\nconst rgbaBufferToYCbCrArray = rgbaBuffer => {\n    // Initialise flat output data array.\n    const yCbCrArray = []\n\n    // Loop over input data array, fetching the luma, chroma blue, and chroma\n    // red values from the red, green, and blue input data values. Skip alpha\n    // channel, and push converted pixel data to the output array.\n    for (let i = 0; i < rgbaBuffer.length; i += 4) {\n        const { luma, chromaBlue, chromaRed } = rgbToYCbCr(\n            rgbaBuffer[i],\n            rgbaBuffer[i + 1],\n            rgbaBuffer[i + 2]\n        )\n        yCbCrArray.push(luma, chromaBlue, chromaRed)\n    }\n\n    return yCbCrArray\n}\n\n/**\n * Convert YCbCr (luma, chroma blue, chroma red) color value to rgb (red, green,\n * blue) color value for use in reversing colorspace used in jpg dct. Please see\n * [this section](https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion) of the\n * wikipedia page for the YCbCr colorspace for more information on the specific\n * values used in this conversion.\n *\n * @param {number} luma - Luma value of color between 0 and 255.\n * @param {number} chromaBlue - Chroma blue value of color between 0 and 255.\n * @param {number} chromaRed - Chroma red value of color between 0 and 255.\n * @returns {{red:number, green:number, blue:number}} Color converted to rgb.\n */\nconst yCbCrToRgb = (luma, chromaBlue, chromaRed) => {\n    // Clamp input channels to values between 0 and 255.\n    luma = clamp(luma)\n    chromaBlue = clamp(chromaBlue)\n    chromaRed = clamp(chromaRed)\n\n    // Rectify chroma values such that they are between -128 and +128.\n    chromaBlue -= 128\n    chromaRed -= 128\n\n    // Return converted colorspace values using coefficients rounded to 2dp.\n    return {\n        red: clamp(luma + 1.40 * chromaRed),\n        green: clamp(luma - 0.34 * chromaBlue - 0.71 * chromaRed),\n        blue: clamp(luma + 1.77 * chromaBlue)\n    }\n}\n\n/**\n * Convert 3-channel YCbCr (luma, chroma blue, chroma red) flat data array into\n * 4-channel rgba (red, green, blue, alpha) flat data array.\n *\n * @param {number[]} yCbCrArray - 3-channel, YCbCr formatted flat data array.\n * @returns 4-channel, rgba formatted flat data array.\n */\nconst yCbCrArrayToRgbaArray = (yCbCrArray, alpha = 255) => {\n    // Initialise flat output data array.\n    const rgbaArray = []\n\n    // Loop over input data array, fetching the red, green, and blue values from\n    // the luma, chroma blue, and chroma red input data values. Push converted\n    // pixel data to the output array with extra alpha channel.\n    for (let i = 0; i < yCbCrArray.length; i += 3) {\n        const { red, green, blue } = yCbCrToRgb(\n            yCbCrArray[i],\n            yCbCrArray[i + 1],\n            yCbCrArray[i + 2]\n        )\n        rgbaArray.push(red, green, blue, alpha)\n    }\n\n    return rgbaArray\n}\n\n// @@exports\nexport { rgbToYCbCr, rgbaBufferToYCbCrArray, yCbCrToRgb, yCbCrArrayToRgbaArray }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Methods for decoding pixel arrays using dct compression algorithm.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@imports-types\n/* eslint-disable no-unused-vars -- Types only used in comments. */\nimport { BlurridMetadata } from \"./BlurridMetadata.js\"\n/* eslint-enable no-unused-vars -- Close disable-enable pair. */\n\n// @@body\n/**\n *\n * @param {number[][][]} array3D\n * @param {BlurridMetadata} metadata\n * @returns {number[][][]}\n */\nconst decodePixelArray3D = (array3D, metadata) => {\n    const [lumaDct, chromaBlueDct, chromaRedDct] = array3D\n\n    const emptyChannel = () => {\n        return Array.from(\n            Array.from({ length: metadata.image.height }),\n            () => Array.from({ length: metadata.image.width }).fill(0)\n        )\n    }\n\n    const channels = [emptyChannel(), emptyChannel(), emptyChannel()]\n    const [lumaChannel, chromaBlueChannel, chromaRedChannel] = channels\n\n    for (let y = 0; y < metadata.image.height; y++) {\n        for (let x = 0; x < metadata.image.width; x++) {\n            const point = {\n                x: x / metadata.image.width * metadata.sample.width,\n                y: y / metadata.image.height * metadata.sample.height\n            }\n\n            lumaChannel[y][x] = decodePixelArray2D(lumaDct, point, metadata)\n            chromaBlueChannel[y][x] =\n                decodePixelArray2D(chromaBlueDct, point, metadata)\n            chromaRedChannel[y][x] =\n                decodePixelArray2D(chromaRedDct, point, metadata)\n        }\n    }\n\n    return channels\n}\n\n/**\n *\n * @param {number[][]} array2D\n * @param {{x:number, y:number}} point\n * @param {BlurridMetadata} metadata\n * @returns {number}\n */\nconst decodePixelArray2D = (array2D, point, metadata) => {\n    const dctRow = []\n\n    for (let i = 0; i < metadata.sample.width; i++) {\n        const dctColumn = array2D[i]\n        dctRow.push(decodePixelArray1D(dctColumn, point.y))\n    }\n\n    return decodePixelArray1D(dctRow, point.x)\n}\n\n// note in this implementation radians is always supplied +ve\n/**\n *\n * @param {number} radians - Angle value in radians, note that in this\n *      implementation the angle is *always* provided as a positive value.\n * @returns {number}\n */\nconst fastCos = radians => {\n    // Rectify angle value to between 0 and 2PI radians using custom mod (while\n    // loop faster than builtin javascript `%` mod operator)\n    while (radians >= Math.PI * 2) { radians -= Math.PI * 2 }\n\n    // Rectify angle value to between 0 and PI radians (note that since angle\n    // value is *always* supplied as a positive value in this implementation,\n    // rectifying to a positive value is not required).\n    if (radians > Math.PI) { radians = 2 * Math.PI - radians }\n\n    // Execute fastCos formula using a rearranged Bhaskara sine approximation\n    // (see here for more https://en.wikipedia.org/wiki/Bh%C4%81skara_I%27s_sine_approximation_formula) @no-wrap\n    if (radians > Math.PI / 2) {\n        radians = (radians - Math.PI) * (radians - Math.PI)\n        return 5 * radians / (radians + Math.PI * Math.PI) - 1\n    }\n    radians *= radians\n    return 1 - 5 * radians / (radians + Math.PI * Math.PI)\n}\n\n/**\n *\n * @param {number[]} array1D\n * @param {number} pointX\n * @returns {number}\n */\nconst decodePixelArray1D = (array1D, pointX) => {\n    let result = 0\n    for (let i = 0; i < array1D.length; i++) {\n        let partial = array1D[i] * fastCos(\n            ((2 * pointX + 1) * Math.PI * i) / (2 * array1D.length)\n        )\n        partial *= i === 0 ? Math.SQRT1_2 : 1\n        result += partial\n    }\n    result *= Math.sqrt(2 / array1D.length)\n    result = Math.round(result)\n    return result\n}\n\n// @@exports\nexport { decodePixelArray3D }\n","// Copyright (c) 2024 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Global variables for buffer start locations for certain data.\n * @author James Reid\n */\n\n// @ts-check\n\n// @@no-imports\n\n// @@body\nconst BUFFER_LOCATIONS = {\n    METADATA: 0,\n    SUBSAMPLING: 48,\n    COEFFICIENTS: 57,\n    ASSUMED_COEFFICIENT_SIZE: 8\n}\n\n// @@exports\nexport { BUFFER_LOCATIONS }\n"],"names":["$ea1325424b5d060b$export$39785c5d1570d2b1","Error","constructor","options","message","key","name","detail","$ea1325424b5d060b$export$83736ebe6a735486","$ea1325424b5d060b$export$c80826d3392ea781","string","modifiers","tabs","tabSize","compoundModifier","modifier","reset","$ea1325424b5d060b$export$e1ac8087f5f1bfe7","decorations","indent","repeat","color","colorModifier","fgColors","black","red","green","yellow","blue","magenta","cyan","white","gray","bright","dim","underline","blink","reverse","hidden","$8884bdd64f3f6eda$export$c28500e84d42e56e","expandedSample","channelData","map","channel","$8884bdd64f3f6eda$var$collapseChannel","length1","length","sampleData","Array","from","fill","i","entries","j","pixel","channel2D","width","channel1D","channelRow","push","$9499b67a6b43b7b7$export$a343f46e34a234f1","image","sample","max","Math","height","resize","round","$88bbf908b96b83e8$export$4f347c1cf22bbd8","buffer","readPointer","lastReadSize","writePointer","lastWriteSize","size","floor","ArrayBuffer","write","int","bitLength","offset","signed","writeable","append","isWriteable","NaN","writeAbsolute","value","writeRelative","relativeSize","abs","writeString","char","charCodeAt","read","readable","isReadable","readAbsolute","readRelative","sign","readString","lengthSize","String","fromCharCode","copy","target","targetStart","sourceStart","sourceEnd","sourceBits","targetBits","ceil","toString","pointer","uint24","view","Uint8Array","byteLength","byte","uint24ToB64","tracer","uint32","bitsRemaining","Number","isInteger","subBit","getView","getUint8","uint8","index","bit","setUint8","startByte","DataView","match","b64ToUint24","padEnd","split","uint6","dict","indexOf","$3a169a73988b325e$export$15fcc258e19c8efc","luma","chromaBlue","chromaRed","total","subsampling","groups","parseInt","subsample","$858b5ee788f7e79c$var$buildDctArray2D","array2D","x","y","sum","$3a43da62ebb03d71$var$clamp","number","minimum","maximum","isInt","min","$3a43da62ebb03d71$export$f8d5c49fa675945f","$3a43da62ebb03d71$export$8bc460b4baf863e7","yCbCrArray","alpha","rgbaArray","$4efc072bdcf08bc5$export$b24f58bb0238ca0c","array3D","metadata","lumaDct","chromaBlueDct","chromaRedDct","emptyChannel","channels","lumaChannel","chromaBlueChannel","chromaRedChannel","point","$4efc072bdcf08bc5$var$decodePixelArray2D","dctRow","dctColumn","$4efc072bdcf08bc5$var$decodePixelArray1D","$4efc072bdcf08bc5$var$fastCos","radians","PI","array1D","pointX","result","partial","SQRT1_2","sqrt","$6833adc9c349e785$export$a17c6f6fb2637705","serializedDct","coefficients","deserializeMetadata","deserializeCoefficients","toImageData","deserializeSubsampling","dctBuilder","next","coefficient","isNaN","subsampleSelector","builders","iteration","done","onmessage","event","decoder","data","postMessage","imageData","ImageData","Uint8ClampedArray","BlurridDecoder","collapseSample","BlurridMetadata","buildDctArray3D","yCbCrArrayToRgbaArray","decodePixelArray3D","BUFFER_LOCATIONS","SubsampleSelector","BitBuffer","DecoratedError","#deserializeMetadata","METADATA","#deserializeSubsampling","SUBSAMPLING","#deserializeCoefficients","COEFFICIENTS","ASSUMED_COEFFICIENT_SIZE","#dctBuilder","expandSample","expandChannel","collapseChannel","decorateFg","decorate","cliModifiers","decorateBg","bgColors","padEndDecorated","maxLength","fillString","decoratorLength","join","padStartDecorated","padStart","toCamelCase","kebabCaseString","isUpper","isSpaced","reduce","acc","cur","isCapital","nextChar","toUpperCase","toLowerCase","toKebabCase","camelCaseString","isNewWord","buildDctArray2D","targetSize","#writeable","#write","#readable","#read","#getView","regex","#b64ToUint24","#uint24ToB64","#bitLength","#dict","WorkerManager","queue","workers","Map","instantiateWorker","limit","callback","addWorker","worker","set","postWorker","dequeue","enqueue","existingWorker","timeLastActive","#dequeue","shift","Date","now","setTimeout","get","terminate","delete","clamp","rgbToYCbCr","rgbaBufferToYCbCrArray","rgbaBuffer","yCbCrToRgb","decodePixelArray2D","decodePixelArray1D","fastCos"],"version":3,"file":"worker.234ccd80.js.map"}